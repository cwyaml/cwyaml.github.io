<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TypeScript基础教程 -- 类]]></title>
    <url>%2F2017%2F09%2F19%2F%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[传统方法中，我们通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 class。TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。 ES6中类的用法使用 class 定义类。使用 constructor 定义构造函数。通过 new 生成新实例的时候，会自动调用构造函数。1234567891011class Animal&#123; constructor (name) &#123; this.name = name; &#125; sayHi() &#123; return `hello,my name is $&#123;this.name&#125;`; &#125;&#125;let a = new Animal('Tom');console.log(a.sayHi()); // hello,my name is Tom 使用 extends 关键字实现继承，子类中使用 super 来调用父类的构造函数和方法。1234567891011class cat extends Animal &#123; constructor (name) &#123; super(name); // 调用父类的constructor(name) &#125; sayHi() &#123; return super.sayHi(); // 调用父类的sayHi() &#125;&#125;let b = new cat('boom');console.log(b.sayHi()); // hello,my name is boom 使用 get 和 set 对某个属性设置存值函数和取值函数，拦截该属性的存取行为。123456789101112131415class Animal &#123; constructor(name) &#123; this.name = name; &#125; set name(value) &#123; console.log('setter: ' + value); &#125; get name() &#123; return 'Jack'; &#125;&#125;let a = new Animal('Kitty'); // setter: Kittya.name = 'Tom'; // setter: Tomconsole.log(a.name); // Jack 通过 static 关键字修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用。12345678class Animal &#123; static isAnimal(a)&#123; return a instanceof Animal; &#125;&#125;let a = new Animal('Tom');Animal.isAnimal(a); // truea.isAnimal(a); // Uncaught TypeError: a.isAnimal is not a function TypeScript中类的用法public、private和protectedTypeScript可以使用三种访问修饰符，分别是：public、private 和 protected。 public 修饰的属性或方法是公有的，可以再任何地方被访问。默认所有的属性和方法都是 public 的； private 修饰的属性或方法是私有的，不能再声明它的类的外部访问； protected 修饰的属性或方法是受保护的，和 private 类似，区别是，它在子类中也是允许被访问的。 举例说明：12345678910class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Tom');console.log(a.name); // Toma.name = 'Jack';console.log(a.name); // Jack 上例中，name 被设置为 public，所以直接访问实例的 name 属性是被允许的。很多时候，我们希望有的属性是无法直接存取的，这时候就要用到 private 了。123456789101112class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Tom');console.log(a.name); a.name = 'Jack';// hello.ts(8,15): error TS2341: Property 'name' is private and only accessible within class 'Animal'.// hello.ts(9,3): error TS2341: Property 'name' is private and only accessible within class 'Animal'.// hello.ts(10,15): error TS2341: Property 'name' is private and only accessible within class 'Animal'. 需要注意的是，TypeScript编译后的代码中，并没有限制 private 属性再外部的可访问性。下面是编译后的代码：12345678910var Animal = /** @class */ (function () &#123; function Animal(name) &#123; this.name = name; &#125; return Animal;&#125;());var a = new Animal('Tom');console.log(a.name); // Toma.name = 'Jack';console.log(a.name); // Jack 另外，使用 private 修饰的属性或方法在子类中是不允许访问的：12345678910111213class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;class cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name); &#125;&#125;// hello.ts(10,22): error TS2341: Property 'name' is private and only accessible within class 'Animal'. 使用 protected 则允许在子类中访问123456789101112class Animal &#123; protected name; public constructor(name) &#123; this.name = name; &#125;&#125;class cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name); &#125;&#125; 抽象类abstract 用于定义抽象类和其中的抽象方法。 首先，抽象类不允许被实例化：1234567891011121314151617181920212223abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;let a = new Animal('Tom');// hello.ts(9,9): error TS2511: Cannot create an instance of the abstract class 'Animal'.``` 上面，我们定义了一个抽象类 Animal 和一个抽象方法 sayHi()，在实例化的时候报错了。其次，抽象类中的抽象方法不许被子类实现：``` tsclass cat extends Animal &#123; public eat() &#123; console.log(`$&#123;this.name&#125; is eating.`); &#125;&#125;let cat1 = new cat('Tom');// hello.ts(9,7): error TS2515: Non-abstract class 'cat' does not implement inherited abstract member 'sayHi' from class 'Animal'. 我们定义了一个类 cat 继承抽象类 Animal，但没有实现抽象方法 sayHi()，所以编译报错。 正确方法：12345678class cat extends Animal &#123; public sayHi() &#123; console.log(`hello, my name is $&#123;this.name&#125;`); &#125;&#125;let cat1 = new cat('Tom');cat1.sayHi(); // hello, my name is Tom 类的类型1234567891011class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; sayHi(): string &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a: Animal = new Animal('Jack');console.log(a.sayHi()); // My name is Jack]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript基础教程 -- 泛型]]></title>
    <url>%2F2017%2F09%2F18%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[软件工程中，我们不仅要创建一致的良好的API接口，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也支持将来的数据类型，这在创建大型功能时提供了十分灵活的功能。泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再定义类型的这一特性。可以使用泛型来创建可重用的组件，一个组件支持多种数据类型，用户根据自己的数据类型来使用组件。 简单的例子首先，我们实现一个函数 creatArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：12345678910111213141516171819202122function creatArray (length: number, value: any): Array&lt;any&gt; &#123; let result = []; for(let i = 0; i &lt; lenght; i++) &#123; result[i] = value; &#125; return result;&#125;console.log(createArray(5, 'hhh'));``` 这段代码不会报错，但有一个明显的缺陷，它没有准确的定义返回值的类型。`Array&lt;any&gt;` 允许数组的每一项都为任意类型，但我们预期的是，数组的每一项都应该是输入的 `value` 的类型。这是，就用到了**泛型**。我们将原来的函数这样写：``` jsfunction createArray&lt;T&gt; (length: number, value: T): Array&lt;T&gt; &#123; let result = []; for(let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;console.log(createArray&lt;string&gt;(5, 'hhh'));console.log(createArray(5, 'hhh')); // 类型推断console.log(createArray&lt;number&gt;(5, 233)); 上例中，我们在函数名后面添加 &lt;T&gt;，其中 T 来指代任意的输入类型，我们称之为泛型变量，后面的 value: T 和 Array&lt;T&gt; 就可以使用了。在调用的时候再指定具体的数据类型 string / number 等。当然也可以不手动指定类型，而让类型推断自己判断。 多个类型参数定义泛型的时候可以一次定义多个类型参数：1234function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123; return [tuple[1], tuple[0]];&#125;swap('seven', 7); 上面我们定义了一个 swap 函数，用来交换输入的元组。 泛型约束在函数内部使用泛型变量的时候，由于事先并不知道它是那种数据类型，所以不能随意的操作它的属性或方法：12345function identity&lt;T&gt; (arg: T): T &#123; console.log(arg.length); return arg;&#125;// hello.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'. 泛型 T 不一定包含属性 .length，所以编译会报错。我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。为此，我们定义一个接口来描述约束条件，使用 extends 关键字来实现约束。12345678910interface lengthWise &#123; length: number;&#125;function identity&lt;T extends lengthWise&gt; (arg: T): T &#123; console.log(arg.length); return arg;&#125;indetity(7);// hello.ts(9,10): error TS2345: Argument of type '7' is not assignable to parameter of type 'lengthWise'.identity('hello'); 调用 identity 的时候，传入的 arg 不含 length 在编译阶段就会报错。 多个类型参数之间也可以互相约束：12345678function copyFields&lt;T extends U, U&gt; (target: T, source: U): T &#123; for (let id in source) &#123; target[id] = (&lt;T&gt;source)[id]; &#125; return target;&#125;let x = &#123;a: 1, b: 2, c: 3, d: 4&#125;;copyFields(x,&#123;b: 5&#125;); // &#123;a: 1, b: 5, c: 3, d: 4&#125; 我们使用了两个类型参数，其中要求 T 继承 U,这样就保证了 U 上不会出现 T 中不存在的字段。 泛型接口可以使用含有泛型的接口来定义函数的形状：1234567891011121314interface createArrayFunc &#123; &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: creaaeArrayFunc;createArray = function&lt;T&gt; (length: number, value: T): Array&lt;T&gt; &#123; let result = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'hh');]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript基础教程 -- 数据类型]]></title>
    <url>%2F2017%2F09%2F07%2Ftypescript%2F</url>
    <content type="text"><![CDATA[什么是TypeScriptTypeScript是JavaScript的一个超集，主要提供了类型系统和对ES6的支持，它有Microsoft开发，代码开源在github上。 引用官方的定义： TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.Any browser. Any host. Any OS. Open source. 翻译成中文即是： TypeScript是JavaScript的类型的超集，它可以编译成纯JavaScript。编译出来的JavaScript可以运行在任何浏览器上。TypeScript编译工具可以运行在任何服务器和操作系统上。TypeScript是开源的。 为什么选择TypeScript这里总结一下其优势： TypeScript增加了代码的可读性和可维护性 类型系统实际上是最好的文档，大部分函数看看类型的定义就可以知道如何使用了 可以在编译阶段就发现大部分错误，这总比在运行是出错好 增强了编辑器和IDE的功能，包括代码补全、接口提示、跳转到定义、重构等 TypeScript非常包容 TypeScript是JavaScript的超集，.js 文件可以直接明明为 .ts 即可 即使不显式的定义类型，也能够自动做出类型推断 可以定义从简单到复杂的一切类型 即使TypeSript编译报错，也可以生成JavaScript文件 兼容第三方库，即使第三方库不是用TypeScript写的，也可以编写单独的类型 TypeScript拥有活跃的社区 大部分第三方库都提供给TypeScript的类型定义文件 Google开发的Angular2就是使用TypeScript编写的 ES6的一部分特性是借鉴的TypeScript的 TypeScript拥抱了ES6规范，也支持部分ES7草案的规范 也说些缺点： 有一定的学习成本，需要理解接口（interfaces）、泛型（generics）、类（classes）、枚举类型（enums）等前端工程师可能不是很熟悉的东西。而且中文资源不多 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript能够减少其维护成本 集成到构建流程需要一些工作量 可能和一些库结合的不是很完美 总之可以根据自己团队和项目的情况判断是否需要使用TypeScript。 安装TypeScript请自行百度Hello TypeScript我们从一个简答的例子开始。将以下代码复制到 hello.ts 中：12345function sayHello(person: string) &#123; return 'Hello,' + person;&#125;let user = 'Tom';console.log(sayHello(user)); 然后执行1tsc hello.ts 这是后会生成一个编译好的文件12345function sayHello(person) &#123; return 'Hello,' + person;&#125;var user = 'Tom';console.log(sayHello(user)); 上述例子中，我们用 : 指定 person 参数类型为 string 。但是编译为 js 之后，并没有什么检查的代码被插入进来。TypeScript只会进行静态检查，如果发现有错误，编译的时候会报错。 下面尝试吧这段代码编译一下：12345function sayHello(person: string) &#123;return 'Hello, ' + person;&#125;let user = [0, 1, 2];console.log(sayHello(user)); 编辑器中会提示错误，编译的时候也会出错： index.ts(6,36): error TS2345: Argument of type ‘number[]’ is not assignable to parameter of type ‘string’. 但是还是生成了 js 文件：12345function sayHello(person) &#123;return 'Hello, ' + person;&#125;var user = [0, 1, 2];console.log(sayHello(user)); TypeScript编译的时候即使报错了，还是会生成编译结果，我们仍然可以使用这个编译后的文件 如果要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可。关于 tsconfig.json ，请参阅官方手册（中文版）。 原始数据类型JavaScript的类型分为两种：原始数据类型和对象类型。原始数据类型包括：布尔值、数值、字符串、null、undefined、以及ES6中的新类型Symbol本节主要介绍前五种原始数据类型在TypeScript中的应用。 布尔值布尔值是最基础的数据类型，在TypeScript中，使用 boolean 定义布尔值类型：12let isDone: boolean = false;// 编译通过 注意，使用构造函数 Boolean 创建的对象不是布尔值：123let createByNewBoolean: boolean = new Boolean(1);// 编译不通过// index.ts(1,5): error TS2322: Type 'Boolean' is not assignable to type 'boolean'. 事实上 new Boolean() 返回的是一个 Boolean 对象，应该这样定义它的类型：1let createByNewBoolean: Boolean = new Boolean(1); 直接调用 Boolean 可以返回一个 boolean 类型：1let createByBoolean: boolean = Boolean(1); 在TypeScript中，boolean是JavaScript中的基本类型，而Boolean是JavaScript中的构造函数。其他基本类型（除了null和undefined）一样，不在赘述。 数值使用 number 定义数值类型：12345678let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity; 编译结果为：12345678var decLiteral = 6;var hexLiteral = 0xf00d;// ES6 中的二进制表示法var binaryLiteral = 10;// ES6 中的八进制表示法var octalLiteral = 484;var notANumber = NaN;var infinityNumber = Infinity; 其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。ES5中的语法不会被转换。 字符串使用 string 定义字符串：1234let myName: string = 'Xcat Liu';let myAge: number = 25;// 模板字符串 注意这里是 tab 上边那个键，而不是单引号let sentence: string = `Hello, my name is $&#123;myName&#125;.I'll be $&#123;myAge + 1&#125; years old next month.`; 编译结果：1234var myName = 'Xcat Liu';var myAge = 25;// 模板字符串var sentence = "Hello, my name is " + myName + ".\nI'll be " + (myAge + 1) + " years old next month."; 空值JavaScript中没有空值的概念，在TypeScript中，可以用 void 表示没有任何返回值的函数：123function alertName(): void &#123; alert('Tom');&#125; 使用 void 声明一个变量没什么用处，因为你只能把它赋值为 null 或 undefined。 Null 和 Undefined在 TypeScrip 中可以使用 null 和 undefined 来定义这两个原始数据类型：12let u: undefined = undefined;let n: null = null; undefined类型的变量只能被赋值为 undefined，null类型的变量只能被赋值为 null。与 void 类型的区别是 undefined 和 null 是所有类型的子类，也就是说 undefined 类型的变量可以赋值给 number/string… 类型的变量：12let num: number = undefined;// 这样写不会报错 编译结果为： var num = undefined; 而 void 类型的变量不能赋值给 number 类型的变量：123let u: void;let num: number = u;// 编译报错：hello.ts(2,5): error TS2322: Type 'void' is not assignable to type 'number'. 任意值任意值（any） 来表示允许赋值为任意类型 什么是任意值类型？如果是普通类型，在赋值过程中改变其类型是不被允许的：123let num: number = 7;num = 'strimg';// hello.ts(2,1): error TS2322: Type '"strimg"' is not assignable to type 'number'. 而如果是 any 类型，则允许被赋值为任意类型：12let num: any = 7;num = 'string'; 未声明类型的变量未声明类型的变量会被识别为 any 类型：1234let something;something = 7;something = 'string';something.setName('Tom'); 相当于：1let something: any; 类型推断在 2.1 版本之后，增加了 类型推断 这一概念。如果没有明确指定类型，TypeScript会按照类型推断的规则来推断出一个类型。以下代码没有指定类型，编译时会报错：123let myFavoriteNumber = 'seven';myFavoriteNumber = 7;// hello.ts(2,1): error TS2322: Type '7' is not assignable to type 'string'. 在TypeScript 2.1 之前，如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查。TypeScript 2.1 中，编译器会考虑对 myFavoriteNumber 的最后一次赋值来检查类型。 联合类型联合类型表示取值可以为多种类型中的一种。举个例子：123let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 如果这样写就会报错：123let myFavoriteNumber: string | number;myFavoriteNumber = true;// hello.ts(2,1): error TS2322: Type 'true' is not assignable to type 'string | number'. 联合类型使用 | 分割每个类型。这里 string | number 的含义是允许 myFavoriteNumber 的类型时 string 或 number 而不能时其他类型。 访问联合类型的属性和方法当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：1234function getLength(something: string | number): number &#123; return something.length;&#125;// hello.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.Property 'length' does not exist on type 'number'. 因为 length 不是 number 和 string 的共有属性，所以会报错。访问 toString() 就没有问题：123function getString(something: string | number): string &#123; return something.toString();&#125; 联合类型的变量在赋值时也会根据类型推断的规则推断出一个类型：123456let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';console.log(myFavoriteNumber.length); //5myFavoriteNumber = 7;console.log(myFavoriteNumber.length); //报错// hello.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'. 上例，在第二行 myFavoriteNumber 被推断为 string，访问其 length 属性不会报错，而第四行 myFavoriteNumber 被推断为 number，访问其 length 属性就报错了。]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑客英雄》书摘]]></title>
    <url>%2F2017%2F08%2F29%2F%E3%80%8A%E9%BB%91%E5%AE%A2%E8%8B%B1%E9%9B%84%E3%80%8B%E4%B9%A6%E6%91%98%2F</url>
    <content type="text"><![CDATA[《黑客英雄》这本书出版于1984年，描述了黑客的历史以及他们的价值观。由于这是该领域的第一本著作，所以引起了广泛反响。1994年出了十周年版，2010年又出了25周年版。计算机书籍的寿命其实很短，三五年前的书大多数已经无人问津，只有那些最重要、最经典的书，才会在二十多年后还有再版价值。 1.They had grown up with a specific relationship to the world, wherein things had meaning only if you found out how they worked. 他们从小就认为，只有知道一件事物的原理，它才是有用的东西。 2.It was the predictability and controllability of a computer system–as opposed to the hopelessly random problems in a human relationship–which made hacking particularly attractive. 计算机是可预测和可控的，而人类不是，这就是计算机的吸引力所在。 3.The Right Thing to do was to make sure that any good program got the fullest exposure possible, because information was free and the world would only be improved by its accelerated flow. 正确的做法是，尽可能广泛地传播优秀的程序。因为信息是免费的，只有加速流动，全世界才能从中受益。 4.No sooner did he decide to do something than he began work on it. He didn’t bother to notify his superiors. 一旦决定了，他就立即动手做，从不请示上级同意，那样太麻烦。 5.[One day,] You realize that computer is not just a random piece of equipment, but something hooked to a system that you can endlessly explore. 突然有一天，你意识到计算机并不是普通的设备，而是一个可以无尽探索的系统。 6.To a hacker, a closed door is an insult, and a locked door is an outrage. 对于黑客来说，关着的门就是一种挑衅，而锁着的门则是一种侮辱。 7.In one side of the world, people were locking everything up and controlling things and preventing information from flowing the wrong way and things from being stolen. 在世界的一端，人们把所有东西都锁起来，严加控制，防止信息不当流动以及发生偷窃。 Then there was another side of the world where people felt everything should be available to everybody. 在世界的另一端，人们认为所有东西都是可以共享的。 8.Bureaucrats knew their survival depended on keeping people in ignorance, by using artificial means–like locks–to keep people under control. 官僚主义者知道，自己的存在取决于人们对他们的作为一无所知。所以，他们就用各种方法（比如锁），将人们置于控制之下。 9.These hackers actually thought that a person was entitled to use a tool just because he thought he could do something useful with it. 黑客认为，只要他能用某种工具做出有用的结果，他就有权使用这种工具。 10.He “wasn’t interested” in the teachers, the students, or anything that went on in school. He was interested in building systems. 他不想上学，对老师、同学、校园生活都没有兴趣。他只想建造自己的系统。 11.Controlling a robot was a step beyond computer programming in controlling the system that was the real world. 开发机器人比编程更高级，因为你在控制真实世界的系统。 12.[Hacker’s programming is like] Hightech Tom Sawyer painting a fence with assembly code. 黑客编程就像汤姆·索亚用汇编语言油漆篱笆。 13.Theorists and grad students did not necessarily see the process of computing as a joyful end in itself: they were more concerned with getting degrees, winning professional recognition, and the, ahem, advancement of computer science. 理论家和研究生，并不是为了编程本身的乐趣而编程，他们只是为了得到学位、获得学术地位、以及所谓的推动计算机科学的进步。 They were all in the midst of scholarly and scientific theses and dissertations which pontificated on the difficulty of doing the kind of thing that hackers were attempting. 他们在论文中大肆宣扬某些问题极其困难，而此时黑客已经在动手尝试解决这些问题。 14.Improve the world by understanding and building systems. 理解和开发计算机系统，从而改变世界。 15.Who you were didn’t matter as much as what kind of hacker you were. 重要的不是你是谁，而是你是哪一类的黑客。 16.The most important thing we can do with the world is avoid randomness, and figure out ways by which things can be planned. 为了建设一个更美好的世界，最重要的就是避免随机性，并找出将一切安排得仅仅有条的方法。 17.All serious computer programs are expressions of an individual. 所有严肃的计算机程序，都是个人的表达方式。 The important thing about a program is that it’s something you can show to people, and they can read it and they can learn something from it. It carries information. It’s a piece of your mind that you can write down and give to someone else just like a book. 程序的最重要之处，就是能够给别人看，被他们阅读，并且有所领会。它包含着信息。它是你个人思想的一部分，你把它写出来，像一本书一样交给他人。 18.One of the really fun things about computers is that you have control over them. When you have a bureaucracy around a computer you no longer have control over it. 计算机的一个真正有趣之处，就是你能够控制它。可是，如果计算机旁边有一个官僚主义者，你就无法控制计算机了。 19.[In some places,] Develop a program that might have only sometimes worked, or might have some danger of crashing the system, that was not encouraged. You want an environment where making those mistakes is not something for which you’re castigated, but an environment where people say, “Oops, you made a mistake.” 有些地方不鼓励你开发那些可能出错的程序，因为它们有让系统崩溃的危险。程序员真正需要的工作环境，就是那种犯错后不会受到责备，别人只会说”哦，你出错了”的环境。 20.The best way to get hackers to do things was to suggest them, and hope that the hackers would be interested enough. Then you would get production unheard of in industry or academia. 让黑客为你工作的最好方法，就是向他们提建议，希望他们会对此产生浓厚兴趣。然后，你就会得到业界或学术界闻所未闻的生产力。 21.It is indeed true that large systems are never “finished.” 大型系统永远没有”完工”的那一天，那是千真万确的。 22.A benevolently anarchistic lifestyle dedicated to productivity and passion. Art, science, and play had merged into the magical activity of programming. 建设性的无政府主义生活方式，会导致生产力和激情。艺术、科学、游戏都神奇地与编程融为一体。 23.[The outside of the world] did not regard computers with the same respect and fascination as did the hackers. And they did not necessarily regard the hackers’ intentions as benign and idealistic. 外部世界不像黑客那样尊崇和迷恋计算机。他们不可能体会到黑客的动机是善意和理想主义的。 24.There were many, many, many years that went by when all I did was hack computers, and I didn’t feel lonely, like I was missing anything. But I guess as I started to grow up more, round out more, change more, become less eccentric in certain ways, I started needing more input from people. 好多好多年以来，我的生活就是与计算机打交道，从未感到过孤独，或缺少了什么东西。但是，我想随着年龄增长，我不再那么偏激了，改变了很多，不再那么偏执于某种生活方式，我开始寻求更多的与他人的交流。 25.It was sort of necessary for these people to be extremely brilliant and in some sense, handicapped socially so that they would just kind of concentrate on this one thing. 他们无比聪明，可是又有着某种程度的社交障碍。这种搭配多多少少是必需的，因为只有这样，他们才能集中精力干一件事。]]></content>
      <categories>
        <category>文学爱好者</category>
      </categories>
      <tags>
        <tag>书摘</tag>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10 图片 Base64 编码]]></title>
    <url>%2F2017%2F06%2F30%2F10---%E5%9B%BE%E7%89%87-Base64-%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[第十周，一起来认识一下 图片的 Base64 位编码 。这有利于优化你的网页。 最后做一个小网页，实现用户上传图片，点击按钮获得该图片的 Base64 位编码的功能。 前言图片处理在前端工作中可谓占据了很重要的一壁江山。而图片 Base64编码 可能相对一些人而言比较陌生，本文希望通过一些浅显的论述，让你知道什么是图片的 base64编码，为什么我们要用它，以及如何方便的使用它。 图片的Base64编码简介图片的 base64编码，就是将一张图片数据编码成一串字符串，使用该字符串代替图像地址。 这样做有什么意义呢？我们知道，我们所看到的网页上的每一张图片，都是通过消耗一个 http请求 下载而来的。没错，每张图片都要请求一次，如果你的网页有非常多的图片，必定要消耗很大一部分资源。 我们就想了：要是图片的下载不用向服务器发出请求，而可以随着 HTML 的下载同时下载到本地那就太好了。而 base64 正好解决了这个问题。 Base64 长什么样子？ 这里贴出百度首页图片的编码：1data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhwAAAECCAMAAAC.................wIcCDAgQAHAhwIcCDAgQAHAhwIcCDAgSDAgQAHAhwIcCDAgQAHAhwIcCDAgQAHggAHAhwIcCDAgfg1/x8Ate1CIJg9Qs4AAAAASUVORK5CYII= 怎么使用呢？ 在 HTML 中的写法：1&lt;img src="data:image/gif;base64,R0lGODlhHAAmAKIH…....."&gt; 在 CSS 中的写法：123#box&#123;background: url(data:image/gif;base64,R0lGODlhHAAmAKIH.......) no-repeat center;&#125; 不得不说的是，这个技术已经过时了，因为图片经过编码后体积会变大（一张 200k 的图片编码后 大概 240K 左右）。尽管节省了 http 请求，但也带来了打开网页时拥堵的问题，有点得不偿失。所以只有很小的图片会考虑使用一下。 目前已经有新的技术来代替：CssSprites 。以后会讲。如果你不感兴趣就不必在往下看了。。 本着折腾精神，还是研究一下。现在开始动手做一个获取图片 Base64 位编码的小网页。 首先实现图片上传及预览1、如果仅仅是上传，我们都知道只需要一个 input 标签就可以完成。就像这样：12345678&lt;div id="box"&gt; &lt;img id="preview" src="" alt=""&gt; &lt;div id="btn"&gt; &lt;input type="file" id="file" accept="image/*"&gt; &lt;button type="button"&gt;获取 Base64 编码&lt;/button&gt; &lt;/div&gt; &lt;textarea name="base64" rows="15" cols="60"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;img&gt; 标签时预览照片的位置，&lt;textarea&gt; 用来显示编码。 注意限制图片上传类型为 图片。 2、做了一点布局12345678910111213141516171819202122232425html&#123; font-size: 625%;&#125;#box&#123; width: 100%; height: 100vh; display: flex; justify-content: center; align-items: center;&#125;img&#123; width: 5rem; height: 3rem; border: 1px solid #ccc; overflow: hidden;&#125;#btn&#123; width: 1.5rem; margin: 0 .1rem; display: flex; flex-direction: column;&#125;#btn button&#123; margin: .1rem 0;&#125; 2、预览怎么实现呢？？我们可以使用 FileReader 。参考文档 中有完整的预览本地文件的代码。 仿照给出的源码写一个预览功能：123456789101112131415161718var inputFile = document.getElementById('file');inputFile.onchange = function imgPreview()&#123; //判断是否支持FileReader if (window.FileReader) &#123; var reader = new FileReader(); &#125; else &#123; alert("换个浏览器试一下！"); &#125; //获取文件 var file = this.files[0]; reader.onload = function(e) &#123; //获取图片dom var img = document.getElementById("preview"); //图片路径设置为读取的图片 img.src = e.target.result; &#125;; reader.readAsDataURL(file);&#125; 这个构造函数目前 Opera 和 Safari 还不支持，所以判断一下。 input 上传的文件是以 list 形式存在的，所以 files[0] 即代表你上传的图片。 3、上传张图片试一下： 注意开发者工具中的变化，上传图片后 &lt;img&gt; 的 src 有了值，并且这个值就是 base64 编码。 4、这就好办了，我们在写个获取 这个编码的函数。123456var button = document.getElementById('button');button.onclick = function()&#123; var preview = document.getElementById('preview'); var textarea = document.getElementById('textarea'); textarea.innerHTML = preview.src;&#125; 这样应该就可以了，我们看一下效果： 确实可以获得 Base64 编码。 到此功能实现。。 文章中如果有错误欢迎指出，非常乐意和大家一起交流。完整代码可到 JavaScript-Programs 下载]]></content>
      <categories>
        <category>每周JS小程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09 做一个音乐播放器]]></title>
    <url>%2F2017%2F06%2F23%2F09---%E5%81%9A%E4%B8%AA%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[第九周，正好我正在整理个人博客，就教大家怎么给博客添加音乐播放器。 效果展示已经把这个功能添加到我的博客：http://www.cwyaml.top 点击 听音乐 看一下效果吧！！ 有人就说了，添加个音乐播放器还不很容易吗？添加个 &lt;audio&gt; 标签不搞定了：12345&lt;audio controls="controls"&gt; &lt;source src="#" type="audio/ogg"&gt; &lt;source src="#" type="audio/mpeg"&gt; Please update your browser!!&lt;/audio&gt; 之间的文字会在浏览器不支持该标签时显示出来 在网页中就会出现这个一个东西： 也挺简洁的哈！！ 但是，如果是这样的话，我还有更好的选择： 网易云音乐外链播放器1、打开这个链接：网易云音乐 2、搜一首你喜欢的歌，进入播放页面； 3、已经看到了吧，专辑封面下面出现了“生成外链播放器”，我们点进去就会出现： 4、好吧（尴尬！），我们换一首赵雷的 成都 5、点击 生成外链播放器 ，就会看到： 6、有 播放器尺寸、是否自动播放等功能可以选择，方框中会出现预览样式。选好后，把下面的代码放在你的页面中就可以了。。 不仅单首歌可以生成外链播放器，歌单也可以，你可以自己尝试一下。（网易真良心企业） 这可比 &lt;audio&gt; 标签好看多了吧！但是很明显有几个缺点： 1、你已经看到了，并不是所有的音乐都可以用，有版权限制； 2、样式不能修改，可能与你页面的风格不符； 总之就是： 不能实现 充分的可定制性 。 自己动手丰衣足食，我们一起来写一个音乐播放器吧！！ 实现功能先说说做出来是什么效果吧。在页面中不出现播放器的样式，而是通过点击页面中某个元素触发，再次点击可以切换歌曲。就这些吧，具体做着再说。。 布局其实并没有布局。页面只有一个按钮。123&lt;div id="box"&gt; &lt;button id="btn" type="button"&gt;点击播放音乐！&lt;/button&gt;&lt;/div&gt; 样式强行加个样式，要对得起 强迫症 这个称号，一个按钮也要做的漂亮一点。123456789101112131415161718192021222324*&#123; margin: 0; padding: 0;&#125;#box&#123; width: 100%; height: 100vh; display: flex; justify-content: center; align-items: center;&#125;#btn &#123; font-family: Arial; font-size: 17px; padding: 12px 35px; background-color: rgb(120, 146, 194); border: 1px solid rgb(78, 96, 150); border-radius: 16px; color: rgb(255, 255, 255);&#125;#btn:hover&#123; background: rgb(71,110,158);&#125;` JS部分思路就是，点击按钮后，创建一个 &lt;audio&gt; 标签添加到页面中。 1、要做音乐播放器，当然我们要有音乐才行。用一个数组来放音乐外链：123456var songs = [ "http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3", "http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3", "http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3", "......"]; 制作音乐外链的方法:下载歌曲，然后上传到云端存储空间（我用的是 七牛云存储）, 就会自动生成外链。所以说你只要能下载到歌曲文件，就都能拿来当背景音乐，至于怎么下载，我就不说了。。 2、然后写一下怎么在页面创建 &lt;audio&gt; 标签吧。123456789function addAudio()&#123; var e = document.getElementById('audio'); e.setAttribute('index',0); e.id = 'audio'; e.loop = false; //不循环 e.innerHTML = 'Please update your browser!!'; document.body.appendChild(e); &#125;&#125; index 属性主要用来记录当前播放的是第几首歌、loop 属性不让歌曲循环播放、然后把这个 audio 添加到 body 中。 3、写一下按钮的 onclick 事件：1234var btn = document.getElementById('btn');btn.onclick = function() &#123; addMusic();&#125; 现在点击按钮后 audio 标签就会被添加到页面中。但是歌曲并不会播放，因为它现在还是这个样子：1&lt;audio index="0" id="audio" src=""&gt;Please update your browser!!&lt;/audio&gt; src 并没有值，所以肯定不会播放了。 4、下面就来给 src 属性赋值吧。因为有三首歌曲，我们还要判断一下添加哪个外链。1234567891011121314function cycle()&#123; var e = document.getElementById('audio'); if(e != null)&#123; var index = parseInt(e.getAttribute('index')); if(index &gt; songs.length - 2)&#123; index = 0; &#125;else&#123; index++; &#125; e.setAttribute('index',index); &#125; e.src = i; e.play();&#125; 先获取到刚才添加的 audio 标签，如果获取到了，取得 index 值，即当前播放的是第几首歌（从 0 开始）。 思考一下： 第一次点击 index = 0、第二次 index = 1、第三次 index = 2，这时我们的三首歌都播放过了，点击第四下时 index = 3，应该停止播放的，所以 songs = [] 中要有一个占位的 空元素 。当点第五次时，歌曲列表要重新循环，所以让此时的 index = 0。 逻辑还是很简单的。。 细节处理1、点我们第一次点击按钮时，向页面中添加了一个 audio 标签，第二次点击时，就不必再次添加了，只需要修改 src 值就可以了。所以上面的代码要修改：1234567891011121314function addAudio()&#123; var e = document.getElementById('audio'); if(e === null)&#123; e = document.createElement('audio'); e.setAttribute('index',0); e.id = 'audio'; e.loop = false; //不循环 e.innerHTML = 'Please update your browser!!'; document.body.appendChild(e); e.addEventListener('ended',function()&#123; go(); //音频播放完毕时触发 ended 事件 &#125;); &#125;&#125; 添加前先判断一下 audio 是否存在。 2、最后做一下简单的封装：12345678910111213141516171819202122232425262728293031323334353637383940function go() &#123; var songs = [ 'http://onk2gpv5u.bkt.clouddn.com/%E5%B1%B1%E4%B8%98-%E6%9D%8E%E5%AE%97%E7%9B%9B.mp3', 'http://onk2gpv5u.bkt.clouddn.com/%E6%88%91%E7%BB%88%E4%BA%8E%E5%A4%B1%E5%8E%BB%E4%BA%86%E4%BD%A0%20%28Live%29-%E6%9D%8E%E5%AE%97%E7%9B%9B.mp3', 'http://onk2gpv5u.bkt.clouddn.com/%E7%8E%8B%E5%8A%9B%E5%AE%8F%20-%20%E9%9C%80%E8%A6%81%E4%BA%BA%E9%99%AA.mp3', '' ]; function addAudio() &#123; var e = document.getElementById('audio'); if (e === null) &#123; e = document.createElement('audio'); e.setAttribute('index', 0); e.id = 'audio'; e.loop = false; e.innerHTML = 'Please update your browser!!'; document.body.appendChild(e); e.addEventListener('ended', function() &#123; go() &#125;) &#125; &#125; function cycle() &#123; var e = document.getElementById('audio'); if (e != null) &#123; var index = parseInt(e.getAttribute('index')); if (index &gt; songs.length - 2) &#123; index = 0 &#125; else &#123; index++ &#125; e.setAttribute('index', index) &#125; e.src = i; e.play(); &#125; addAudio(); var SongIndex = parseInt(document.getElementById('audio').getAttribute('index')); var i = songs[SongIndex]; cycle();&#125; 这就是一个完整的音乐播放器了。 3、调用其实就是执行 go() 函数，更新歌曲就修改一下 songs[] 数组就行了。。 终于写完了！！ 文章中如果有错误欢迎指出，非常乐意和大家一起交流。完整代码可到 JavaScript-Programs 下载]]></content>
      <categories>
        <category>每周JS小程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08 Variables CSS变量]]></title>
    <url>%2F2017%2F06%2F15%2F08---Variables-CSS%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[第八周了，讲一个知识点 CSS3 中出现了很多非常实用的新特性，今天就带着大家做一个简单的 图片修改器（就这么叫吧），顺便了解几个新的知识。 效果预览 说明: 本篇文章主要讲一个重要的知识：CSS变量 。（原生支持的，而不是SASS、LESS等预处理器） 布局1234567891011121314151617&lt;div id="title"&gt;Update CSS Variables with JS&lt;/div&gt;&lt;div class="controls"&gt; &lt;label for="border" class="label"&gt;Border:&lt;/label&gt; &lt;input type="range" id="border" name="spacing"&gt; &lt;label for="radius" class="label"&gt;Radius:&lt;/label&gt; &lt;input type="range" id="radius" name="radius"&gt; &lt;label for="blur" class="label"&gt;Blur:&lt;/label&gt; &lt;input type="range" id="blur" name="blur"&gt; &lt;label for="colors" class="label"&gt;Border Color:&lt;/label&gt; &lt;input type="color" id="colors" name="baseColor"&gt;&lt;/div&gt;&lt;div id="box"&gt; ![](bg.jpg)&lt;/div&gt; 1、首先一个 #title来放标题； 2、然后是我们修改图片的按钮之类的，都放在 .controls 里面； 3、只做四个选项：调整图片的边框（Border）、图片边框圆角（Radius）、模糊（Blur） 和 图片边框颜色（colors）； 4、#box 来放图片。 样式123456789101112131415161718192021222324252627282930313233343536html,body&#123; margin: 0; padding: 0; background: #193549; color: #fff; font-size: 10px;&#125;#title&#123; width: 100%; height: 15vh; font-size: 4rem; display: flex; justify-content: center; align-items: center;&#125;.controls&#123; width: 70%; height: 10vh; margin: 0 auto; display: flex; justify-content: space-around; align-items: center;&#125;.label&#123; font-size: 2rem;&#125;input&#123; width: 100px;&#125;#box&#123; width: 100%; height: 75vh; display: flex; justify-content: center; align-items: center;&#125; 1、你没有看错，我又又用了 Flex布局 。（这个方法有毒，用了就停不下来。。） 如果你还不会这种方式，赶紧去看看我的这篇教程吧！！Flex布局教程 - 语法 2、别的都很简单，就不说了。。 接下来是我们今天的重点知识：我们来为图片设置样式：1234567891011:root&#123; --baseColor: #000; --blur: 2px; --spacing: 5px; --radius: 5px;&#125;img&#123; border: var(--spacing) solid var(--baseColor); border-radius: var(--radius); filter: blur(var(--blur)); /*滤镜*/&#125; 1、:root 表示文档树的根元素。在这里即代表 html。这么说吧，:root 就是一个 &lt;html&gt; 专属的 CSS 选择器（应该懂了吧！）。 参考文档 2、--XX 这个就是 CSS变量 定义的方式。 --baseColor 是一个变量，--blur 也是一个变量。写在 :root 中就表示我们定义的这四个是全局变量。 参考文档 3、怎样使用刚才定义好的 CSS变量呢？？ 你只需要这样 var(--XX)就可以给了。就像上面的代码那样。 4、filter: blur(); 是一个滤镜工具，功能非常强大。可以通过使用滤镜达到不同的视觉效果，我们这里使用了 blur() 模糊功能。常见的滤镜还有 透明度滤镜opacity()、灰度滤镜grayscale() 等。你可以尝试着给你的页面添加其他功能。 参考文档 这样，我们只需要改变 CSS变量 图片的相应参数就会改变。 JS部分1234567const inputs = document.querySelectorAll('input');inputs.forEach(input =&gt; input.addEventListener('mousemove',updateData));inputs.forEach(input =&gt; input.addEventListener('change',updateData));function updateData()&#123; const data = this.dataset.sizing || ''; document.documentElement.style.setProperty(`--$&#123;this.name&#125;`,this.value+data);&#125; 1、inputs 返回一个nodelist，是页面中所有的 input 节点。 2、使用 forEach() 为每个节点设置 mousemove 事件。可以在该滑块的值变化时实时的改变CSS全局变量。 3、之所以又监听元素 change 事件，是因为 baseColor，当改变了颜色的值时，只监听 mousemove 事件，无法实时的改变颜色，直到鼠标从color颜色块上滑过，添加 change 事件就可以当改变过后实时的改变。。 4、this.dataset.sizing 返回 data-sizing 属性的值。dataset 可以返回该元素所有自定义的 data-* 属性（前面的文章中我们已经使用过这个属性了）。我们用 data-sizing 来存放该对象的值的单位。举个例子：12&lt;label for="border" class="label"&gt;Border:&lt;/label&gt;&lt;input type="range" id="border" name="spacing" data-sizing="px"&gt; border 属性的单位是 px，我们就把它的 data-sizing 属性值设置为 px。 5、为什么要设置单位呢？？因为通过 this.value 获取的值没有单位，不能直接设置为 CSS属性。而我们又不能这样写：1document.documentElement.style.setProperty(`--$&#123;this.name&#125;`,this.value+'px'); 因为 border 、radius 和 blur 的值都有单位，而 baseColor 并没有单位。。所以这个 data-sizing 属性是必须设置的。 6、还要注意一点：--${this.name} 外面包裹的是 ESC 键下面的那个键打出来的 符号，而不是单引号。。。 到这里就完了吗？？哈哈哈，当然不是。 我们还要动手设置一下这些值改变的范围，比如说：我们要让图片的边框在一定的范围内改变，而不是无限变大，那样就会影响你的布局，用户体验就非常不好。。怎么设置呢？？ 新的 HTML 代码：12345678910111213&lt;div class="controls"&gt; &lt;label for="border" class="label"&gt;Border:&lt;/label&gt; &lt;input type="range" id="border" name="spacing" min="1" max="30" value="5" data-sizing="px"&gt; &lt;label for="radius" class="label"&gt;Radius:&lt;/label&gt; &lt;input type="range" id="radius" name="radius" min="0" max="50" value="5" data-sizing="px" data-sizing="px"&gt; &lt;label for="blur" class="label"&gt;Blur:&lt;/label&gt; &lt;input type="range" id="blur" name="blur" min="0" max="10" value="2" data-sizing="px"&gt; &lt;label for="colors" class="label"&gt;Border Color:&lt;/label&gt; &lt;input type="color" id="colors" name="baseColor" value="#000"&gt;&lt;/div&gt; 1、min 为可取的最小值，max 为可取的最大值，value 为默认值。 2、也把 data-sizing 这个表示单位的属性写上去了。 到此，全部完成！！ 文章中如果有错误欢迎指出，非常乐意和大家一起交流。完整代码可到 JavaScript-Programs 下载]]></content>
      <categories>
        <category>每周JS小程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样给网站添加进度条]]></title>
    <url>%2F2017%2F06%2F13%2F%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[这是最近看到的一个面试题。想一想自己还真不会，于是就研究了一下。。 进度条有很多种，自己感觉下来，自己最喜欢 YouTuBe 的实现方式。样式简约却也美观，增加用户体验的同时对整个网站的布局结构什么的不造成任何影响，确实很完美。 更完美的是：只需要向你的页面引入一个 js 文件就可以实现这个效果 今天介绍的就是这个插件：pacejs 官网： PACEPACE – Automatic page load progressGitHub： HubSpot/pace 使用方法到官网下载文件后，你只需要这样就可以了：12&lt;link rel=&quot;stylesheet&quot; href=&quot;pace-theme-minimal.css&quot; type=&quot;text/css&quot;&gt;&lt;script src=&quot;pace.js&quot;&gt;&lt;/script&gt; 引入的 css 文件是 pace 官方提供的进度条样式文件，有十种左右可以选择。 那么问题来了pacejs 是怎么监控页面的加载进度的呢？？ 通过 官方文档 我们可以知道，pacejs 提供四种监控器：Ajax、Elements、Document 和 Event Lag。 1、首先是 document。document 就是我们所熟悉的 HTML 文档节点（代表的就是这个文档）。当我们向服务器请求页面时，document 节点有一个 onreadystatechange 事件，当 document 的 readyState 状态变化时会触发。因为无法准确的知道 document 到底加载了多少百分比，所以就用这个状态来做一个估算。在 pace.js 中将document 的 readyState 的三个状态 UNSENT，LOADING 和 DONE 分别定义为 0%，50% 和 100%。通过监听 document 节点的 readyState 状态变更，形成了 pace.js 的 Document 监控器。 XMLHttpRequest.readyState 2、接下来是 elements，监听 progressEvent 事件（也就是页面的每个 http 请求，页面中的每一个 img、link、audio 等都需要一个 http 请求）。进度就应该是 ProgressEvent.loaded / ProgressEvent.total（当前进程已经执行的工作量 / 进程正在执行的工作总量） ProgressEvent 3、然后是 eventLag。这个不是很明白，有人这样说： EventLagMonitor 其实只是一个“假的”监视器。它就在那里安静匀速的更新进度，这一小小的措施却带来了不错的用户体验，让用户不会因为加载“卡住了”而慌张。 4、最后是 Ajax。也不懂。。。。。。。 求高手指点。]]></content>
      <categories>
        <category>前端杂货铺</category>
      </categories>
      <tags>
        <tag>网站优化</tag>
        <tag>进度条</tag>
        <tag>用户体验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http填坑]]></title>
    <url>%2F2017%2F06%2F09%2FHTTP-%E5%A1%AB%E5%9D%91%2F</url>
    <content type="text"><![CDATA[什么是http很多书或教程中都讲的很明白：http就是一种协议，计算机之间要共同遵守这个协议的规则才能相互之间通信。当然现在不局限于计算机，还包括手机、电视机、冰箱等智能终端。 这个协议使用中的大致流程是这样的： 1、http客户端发起请求，创建端口比如用手机上的浏览器访问 www.baidu.com ，就创建了一个从浏览器到服务器指定端口的 tcp 连接（默认为 80 端口） 2、http 服务器在指定端口监听客户端的请求 3、一旦收到请求，http 服务器向客户端返回响应和内容比如 200 的状态码，请求的文件、图片、json数据等。 这么说可能还不是很清楚，只是为了让你有一个大致的思路。 下面就以用 chrome 浏览器访问 www.baidu.com 为例，用通俗易懂的方式具体讲一下 当我们在浏览器地址栏输入网址并敲击回车后发生了什么？？ http请求过程1、chrome 浏览器搜索自身 dns 缓存。查看 chrome 浏览器 dns 缓存的方法是在地址栏输入：chrome://net-internals/#dns。回车后就会看到类似下面这些信息 这些缓存信息不会保存很长时间，有的教程上说只保留一分钟，自己实验了一下，只有当浏览器关闭后才会清空（还有待考究）。 如果在浏览器自身的 dns 缓存中找不到我们需要的信息，或者信息过期了，就进行下一步 2、搜索操作系统自身的 dns 缓存查看操作系统 dns 缓存的方法是：开始 &gt; 运行 &gt; 输入cmd &gt; 运行ipconfig/displaydns 命令。就会看到以下信息： 或者查看 dns 缓存文件，保存在 C:\WINDOWS\system32\drivers\etc 下的 hosts.sam 如果没有找到，进行下一步 3、读取本地的 host 文件host 文件应该都很熟悉，目录为 C:\WINDOWS\system32\drivers\etc 。他的作用也不用多讲了吧！！ 如果没有对应的解析，说明本机已经无法搞定这个请求了，我们就要寻求帮助了，，具体找谁，请往下看。。 4、浏览器发起一个 dns 的系统调用 浏览器以系统的名义向本地宽带运营商的 dns 服务器发起一个域名解析的请求。具体是这样的: 1) 运营商服务器查找自身缓存，找到则返回，没有找到则进行下一步 浏览器: 老大哥，www.baidu.com 的 ip 地址是多少啊？运营商dns服务器: 你先等会啊，我给你找一下。 2) 运营商服务器向 根域名服务器 发起一个域名解析请求 运营商 dns 服务器: hey,哥们，www.baidu.com 的 ip 地址是多少啊？根域名服务器: 我怎么知道啊，我只知道 .com 域的 ip 地址，你去问一下它吧！ 全球共有 13 台根逻辑域名服务器。这 13 台逻辑根域名服务器中名字分别为 “A” 至 “M”，真实的根服务器在 2014 年 1 月 25 日的数据为 386 台，分布于全球各大洲。根域名服务器中虽然没有每个域名的具体信息，但储存了负责每个域（如.com, .cn, .ren, .top等）的解析的域名服务器的地址信息。 详细信息请点击：根域名服务器 – 百度百科 3) 运营商 dns 服务器向 .com域 服务器发起一个域名解析请求 运营商 dns 服务器: hey,哥们，www.baidu.com 的 ip 地址是多少啊？.com域 服务器: 我怎么知道啊，我只知道 baidu.com 的 ip 地址，你去问它吧！ 4) 运营商 dns 服务器向 baidu.com域 的 dns 服务器发起一个域名解析请求 运营商 dns 服务器: hey,哥们，www.baidu.com 的 ip 地址是多少啊？baidu.com域 服务器: 我擦，果然在我这。兄弟辛苦了，拿去吧！ 这个 baidu.com 域 服务器是你的域名注册商提供的，比如万网等 5) 运营商服务器拿到了 www.baidu.com 的 IP 地址后，将其返回给我们的操作系统内核，同时缓存起来。 6) 内核在把这个结果返回给浏览器。 5、 浏览器拿到域名的 ip 地址后，发起经典的 HTTP “三次握手”。浏览器拿着这个 IP 地址向 服务器的web程序 发起一个 tcp 连接请求，这个连接请求经过层层的路由设备到达 服务器端 后通过网卡进入内核的 tcp/ip 协议栈，还有可能要经过防火墙，最终这个tcp/ip 请求就建立起来了。 那么 三次握手 干了啥呢？ 客户端： hey,哥们，你能听到我说话吗？服务器端： 兄弟，我能听到，咱唠唠。客户端： 好的，咱开始唠吧！ 三次握手 – 百度百科 很蛋疼有没有，，但三次握手就是这样的。 6、tcp/ip 连接建立起来后，浏览器就可以向服务器发送 HTTP 请求了，比如说使用 get 方式请求一个域名。 7、服务器收到这个请求后，根据路径参数，再经过后端的一些处理，把结果返回给浏览器，这样我们就得到了该域名对应的整个页面的代码或者其他的数据。 8、浏览器拿到代码后，经过解析、渲染等，我们就看到了这个页面。值得说的是，页面中的每一个 css 、js、图片等静态资源都需要一个 HTTP 请求。都需要上面的 七个步骤。 以上观点属个人粗浅的理解，如有错误请指出。。]]></content>
      <categories>
        <category>前端杂货铺</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DIV模拟textarea的实现]]></title>
    <url>%2F2017%2F06%2F06%2Fdiv-%E6%A8%A1%E6%8B%9F-textarea%2F</url>
    <content type="text"><![CDATA[textarea 是一个表单元素，用于多行文字的输入。在web应用上常见的是： 评论输入框，微博输入框等。 就像下面这样： 作为多行文本域功能来讲，textarea 已经能够满足我们大部分的需求。然而，textarea 有一个不足就是 高度不能跟随内容自适应。这样我们就要考虑应用场景，将其预先设置为合适大小。 这时我们想到 div 元素的尺寸是由其子元素决定的，那么 div 能不能拿来替代 textarea 呢？1、首先我们得让 div 变得像 input 那样，点击后可以输入信息。HTML5 中有一个属性 contenteditable 可以决定内容是否可编辑。1&lt;div id=&quot;box&quot; class=&quot;text_box&quot; contenteditable=&quot;true&quot;&gt;&lt;/div&gt; 这样，点击这个 div 后就会在其内部出现一个光标，想输入什么就输入什么。。 2、高度自适应123456789#box&#123; width: 400px; min-height: 100px; max-height: 300px; height: auto; outline: none; border: 1px solid #f00; overflow-y: auto; &#125; 最主要的是把 height 值设置为自适应，其高度就会随内容变化，另外max-height、overflow-y设置当内容超出最大高度后出现滚动条。 其实就是这么简单，我们就实现了。。。前方高能！！ contenteditable 属性有一个牛逼的地方（自己看）： 粘贴带 html 样式，虽然并没有什么卵用。。]]></content>
      <categories>
        <category>前端杂货铺</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07 Barrage 弹幕实现原理]]></title>
    <url>%2F2017%2F06%2F04%2F07---Barrage-%E5%BC%B9%E5%B9%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[第七周、讲一下 弹幕 的实现原理。 说明：弹幕分两种：1、像优酷、爱奇艺等，记录用户发送弹幕时该视频播放的位置，其他人播放这个视频时到了这个点就显示弹幕。 2、像斗鱼、熊猫这样的直播网站，用户发送弹幕直接显示在屏幕上，以后不需要再显示了。 我们就来做第二种！！！ 实现效果 项目分析1、获取用户输入信息； 2、在页面中创建一个 &lt;span&gt;&lt;/span&gt; 来放获取到的文本，并添加一些样式（字体大小、颜色等）； 3、给这个 span 添加一个从右向左移动的动画； 4、动画结束后，移除这个 &lt;span&gt;。 思路很清楚了，就来动手实现一下。。 布局页面中要有一个输入框让用户输入信息，还要一个盒子用来显示弹幕。为了美观，我多加了一些东西。12345678910&lt;div class="box" id="box"&gt; &lt;div id="dm"&gt;&lt;/div&gt; &lt;div class="idDom" id="idDom"&gt; &lt;div id="content"&gt; &lt;p class="title"&gt;吐槽:&lt;/p&gt; &lt;input type="text" class="text" id="text" placeholder="请输入你想说的话~~"/&gt; &lt;button type="button" class="btn" id="btn"&gt;发射!&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1、#dm 是显示弹幕的区域，input 供用户输入信息（其中 placeholder 属性规定输入框中默认显示内容）。 2、其它元素都是为了美观和布局。 样式跟以前一样，先给出代码然后再讲解。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061html,body&#123; margin: 0; padding: 0; font-size: 10px; overflow: hidden;&#125;#box&#123; width: 100%; height: 100%;&#125;#dm&#123; width: 100%; height: 90vh; background: #E8F1F5;&#125;#dm span&#123; width: auto; height: 3rem; font-size: 2rem; line-height: 2rem; position: absolute; white-space: nowrap;&#125;#idDom&#123; width: 100%; height: 10vh; background: #666; position: absolute; bottom: 0; display: flex; align-items: center; justify-content: center;&#125;#content&#123; width: 50rem; height: 10vh; display: flex; align-items: center; justify-content: center;&#125;.title&#123; font-size: 2.2rem; color: #fff; line-height: #ccc&#125;.text&#123; width: 30rem; height: 2.5rem; border: none; border-radius: .5rem; font-size: 1.4rem; padding: 0 1rem; margin: 0 .5rem; /*三个元素的间距*/&#125;.btn&#123; width: 6rem; height: 3rem; border: none; background: #f00; color: #fff;&#125; 1、首先还是格式化浏览器默认的 margin 和 padding。overflow 属性设置超出屏幕的部分隐藏，这样就不会出现下拉和水平的滚动条了。 2、#dm 用来显示弹幕，我们把它的高度设置为 90vh。vh 是 CSS3 中新增的长度单位，表示相对于视口的高度。视口高度被均分为100单位的vh，90vh 就表示当前浏览器可视区域高度的 90%。（vw 就是视口宽度） 感觉 CSS3 中新增的内容使用起来很顺手，很有必要了解一下 3、#dm span 是每条弹幕的样式。你可以修改为你喜欢的样子，不过一定要设置 position 定位属性。 4、然后就是下面的输入部分了。使用了 flex布局 （也是CSS3 中新增的内容，太方便了）。只需要 align-items:center;justify-content:center; 这两句就可以使其中的子元素在水平和垂直方向居中。所以 #idDom 和 #content 都使用了。 5、然后就是 输入框、按钮的样式了，没什么好说的，应该都能看懂。 JS部分先看看代码吧。。12345678910111213141516171819202122232425262728293031323334353637383940414243var btn = document.getElementById('btn');btn.onclick = function()&#123; addBarrage();&#125;document.onkeydown = function(evt)&#123; var event = evt || window.event; if(event.keyCode == 13)&#123; addBarrage(); &#125;&#125;var colors = ['#2C3E50','#FF0000','#1E87F0','#7AC84B','#FF7F00','#9B39F4','#FF69B4'];function addBarrage()&#123; clearInterval(timer); var text = document.getElementById('text').value; //获取用户输入的值 document.getElementById('text').value = ''; //parseInt(Math.random()*(n-m+1)+m);//生成一个从 m - n 之间的随机整数 var index = parseInt(Math.random() * 7); //生成一个0~6的随机数 var screenW = window.innerWidth; var screenH = dm.offsetHeight; var max = Math.floor(screenH / 40); var height = 10 + 40 * (parseInt(Math.random() * (max + 1)) - 1); var span = document.createElement('span'); span.style.left = screenW +'px'; span.style.top = height +'px'; span.style.color = colors[index]; span.innerHTML = text; var dmDom = document.getElementById('dm'); dmDom.appendChild(span); timer = setInterval(move,10);&#125;function move()&#123; var arr= []; var oSpan = document.getElementsByTagName('span'); for(var i = 0;i &lt; oSpan.length;i++)&#123; arr.push(oSpan[i].offsetLeft); arr[i] -= 2 oSpan[i].style.left = arr[i]+'px'; if (arr[i] &lt; -oSpan[i].offsetWidth) &#123; var dmDom = document.getElementById('dm'); dmDom.removeChild(dmDom.childNodes[0]); &#125; &#125;&#125; 1、说明：向页面添加弹幕使用 addBarrage() 函数，添加动画用 move() 函数。（把一种功能封装为一个函数是一个好习惯） 2、首先思考一下弹幕的触发事件。应该有两个：点击“发射”按钮、按下 Enter 按键。所以分别监听点击 和 键盘事件。12345678910var btn = document.getElementById('btn');btn.onclick = function()&#123; addBarrage();&#125;document.onkeydown = function(evt)&#123; var event = evt || window.event; //兼容IE if(event.keyCode == 13)&#123; addBarrage(); &#125;&#125; 3、然后就要思考怎么向页面添加弹幕了？ 先得到用户输入的信息 1var text = document.getElementById('text').value; 然后在页面中创建一个 &lt;span&gt;&lt;/span&gt; ，把得到的文本放进去 12var span = document.createElement('span');span.innerHTML = text; 添加到 #dm 这个盒子中： 12var dmDom = document.getElementById('dm');dmDom.appendChild(span); 这样就可以了吗？？ 当然不是的。。 4、每条弹幕应该有不同的颜色，这样才炫酷。思路就是把预先的颜色放进一个数组，使用的时候用随机的下标，这样就获得了随机颜色。（借鉴斗鱼的 7 中颜色）123var colors = ['#2C3E50','#FF0000','#1E87F0','#7AC84B','#FF7F00','#9B39F4','#FF69B4'];var index = parseInt(Math.random() * 7); //生成一个0~6的随机数span.style.color = colors[index]; 这样每条弹幕就有不同的颜色了。 生成一个从 m ~ n 之间的随机整数的公式parseInt(Math.random()*(n-m+1)+m); 5、每条弹幕在页面上还要有不同的位置（高度），也就是不同的 top 值。我的想法是，虽然要有不同的 top ，但也不能太随意。就像下面这样：（一行是一行的） 我的思路是：先判断页面可以放多少行？12var screenH = dm.offsetHeight;var max = Math.floor(screenH / 40); 然后计算可以有的 top 值：（加 10 是为了不至于紧挨着屏幕顶部，最后的 -1 是为了不至于太靠下 ）1var height = 10 + 40 * (parseInt(Math.random() * (max + 1)) - 1); 你可以自己理解一下我的这种计算方式。。 然后应用给 &lt;span&gt; 即可：1span.style.top = height +'px'; 6、对了，弹幕应该添加到页面的什么位置呢？因为弹幕要从右往左移动，所以应该添加到屏幕的右侧，left 值为浏览器页面的宽度。这时候就知道为什么前面要设置 body 的 overflow: hidden; 了吧！！12var screenW = window.innerWidth;span.style.left = screenW +'px'; 动画弹幕（也就是&lt;span&gt;）被添加到页面中了，我们要让他动起来。 思路就是写一个函数，减少 &lt;span&gt; 的 left 值。每隔几毫秒执行一次这个函数，我们看起来这个 &lt;span&gt; 元素就动起来了。 7、但是有几个问题： 页面中有多少个弹幕（）？因为页面中只有 弹幕 使用的是 &lt;span&gt; 标签，所以这样就可以获取所有 &lt;span&gt; 的 nodeList（类似数组但不是数组，可以使用下标索引访问）： 1var oSpan = document.getElementsByTagName('span'); 怎样记录每条弹幕的 left 值？获取到所有的 &lt;span&gt; 后，用一个 for 循环将每一个 &lt;span&gt; 的 left 值放进一个数组： 1234var arr = [];for(var i = 0;i &lt; oSpan.length;i++)&#123; arr.push(oSpan[i].offsetLeft);&#125; 这样 arr[] 就保存了所有弹幕的 left 值。 8、接下来我们就逐个减少每条弹幕的 left 值：12arr[i] -= 2oSpan[i].style.left = arr[i]+'px'; 9、最后判断如果弹幕已经移出了页面的左边，就把这条弹幕删除了吧。1234if (arr[i] &lt; -oSpan[i].offsetWidth) &#123; var dmDom = document.getElementById('dm'); dmDom.removeChild(dmDom.childNodes[0]);&#125; 我们可以在开发工具中看一下这个过程： 弹幕的 left 一直减小，移出页面后 #dm 中就没有这个 &lt;span&gt; 了。 10、最后处理一个小细节吧！当我们点击按钮或按回车后，输入框中的文字会保留，影响我们下次输入，所以只要获取到了用户输入的内容，就把输入框清空吧！1document.getElementById('text').value = ''; 到此，弹幕就实现了。。。 文章中如果有错误欢迎指出，非常乐意和大家一起交流。完整代码可到 JavaScript-Programs 下载]]></content>
      <categories>
        <category>每周JS小程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06 The Matrix 黑客帝国]]></title>
    <url>%2F2017%2F05%2F29%2F06---The-Matrix-%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[第六周，做点什么呢？？想必大家都看过 黑客帝国 系列电影吧！先放一张图片致敬一下经典。 我们就来做一下里面的背景特效吧：The Matrix 效果预览 是不是很赞！！一起来实现一下吧！！ 项目分析1、用到 HTML5 中的 canvas 知识； 2、使用 js 生成随机的字符； 3、把整个页面当做一个 canvas 画布，把字符画上去； 4、重复这个动作：生成字符、画到页面上。需要考虑的是每次字符在页面的位置。 HTML&amp;CSS页面中只有一个 canvas 画布，所以不需要什么布局。1234567&lt;!-- html --&gt;&lt;canvas id="content" width="1366px" height="768px"&gt;&lt;/canvas&gt;&lt;!-- css --&gt;*&#123; margin: 0; padding: 0;&#125; 1、因为 canvas 尺寸的改变会使里面的内容重新绘制，所以为了不影响最后的效果，最好将这个值设置为本机的屏幕分辨率。（至于怎么影响效果后面会讲） 2、取消浏览器默认的 margin 和 padding。 JS部分同样先上代码：12345678910111213141516171819202122var cav = document.getElementById('content');var w = window.screen.width;var h = window.screen.height;var yPositions = Array300).join(0).split(''); var ctx = cav.getContext('2d'); //初始化画布var draw = function()&#123; ctx.fillStyle = 'rgba(0,0,0,.05)'; ctx.fillRect(0,0,w,h); ctx.fillStyle = 'green'; ctx.font = '20px'; yPositions.map(function(y,index)&#123; text = String.fromCharCode(1e2 + Math.random() * 330); //生成随机字母 x = index * 10; cav.getContext('2d').fillText(text,x,y); if (y &gt; Math.random() * 1e4) &#123; yPositions[index] = 0; &#125; else &#123; yPositions[index] = y + 10; &#125; &#125;);&#125;setInterval('draw()',30); 1、首先获取画布； 2、获取本机显示器的分辨率：12var w = window.screen.width;var h = window.screen.height; 3、然后要在页面中画出一个矩形（这个就是整个特效的范围）。前面说过，canvas 的尺寸会影响最后的效果，是因为，我们不能动态的改变 canvas 的尺寸（那样会使 canvas 重新绘制），所以当页面绘制好后我们再去调整浏览器的尺寸是就会产生白边，你可以去试一下。。。 所以解决办法就是直接把 canvas 的尺寸设置为屏幕的分辨率。这样不管怎么调整，浏览器的尺寸都不可能比屏幕还大吧。12ctx.fillStyle = 'rgba(0,0,0,.05)';ctx.fillRect(0,0,w,h); 4、然后就应该考虑怎样来生成随机字符了。我们用了这样一段代码：1text = String.fromCharCode(1e2 + Math.random() * 330); fromCharCode(num) 会返回一个 Unicode 编码为num 字符。所以这句话理论上可以写成 fromCharCode(Math.random * n) 。（只要 num 的范围在 0000 - FFFF） 对于 Unicode 编码，他为世界上所有的字符进行了编码。十六进制范围为从 0000 - FFFF，其中中文字段在 4E00-9FA5。 5、map(callback()) 方法创建一个新数组，其结果是该数组中的每个元素调用一个提供的函数。callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。所以没执行一次 draw() 函数会在 X 方向上生成一排的字符。 6、用 x 和 y 来指定字符在页面中的位置。x 指定没列字符占 10px 的宽度，y 同样每次增加 10px，为每个字符在 y 方向占 10px 高度。当然每列字符不可能数量都相同，所以只要 y 的值大于一个随机数之后新的字符就生成在页面顶部。123456x = index * 10;if (y &gt; Math.random() * 1e4) &#123; yPositions[index] = 0;&#125; else &#123; yPositions[index] = y + 10;&#125; 7、忘记说了，再次之前要生成一个值全部为 0 的数组，主要控制字符的列数。1234var yPositions = Array(300);yPositions.fill(0); //也可以这样写//var yPositions = Array(300).join(0).split(''); 完成。。。 文章中如果有错误欢迎指出，非常乐意和大家一起交流。完整代码可到 JavaScript-Programs 下载]]></content>
      <categories>
        <category>每周JS小程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05 Magnifier 放大镜]]></title>
    <url>%2F2017%2F05%2F21%2F05---Magnifier-%E6%94%BE%E5%A4%A7%E9%95%9C%2F</url>
    <content type="text"><![CDATA[第五周，做一个网店都有的图片放大功能：Magnifier 实现效果 项目分析1、首先可以确定页面中必须有两长相同的图片，一直展示的照片要缩小，被放大的图片设置原始大小； 2、右侧的图片要默认隐藏，只有当鼠标放在左侧图片上时才显示； 3、在左侧图片上还要有一个 选择框 跟随鼠标的移动，代表要放大的图片范围，但不能移动出图片范围； 4、还要注意 两张图片 还有 选择框 尺寸之间的关系。 下面来动手实现一下。。。 基本的布局12345&lt;span id="sp1"&gt;&lt;/span&gt;![](timg.jpg)&lt;div id="box"&gt; ![](timg.jpg)&lt;/div&gt; 1、两张图片分别为 img1 和 img2; 2、&lt;span&gt; 为选择框，在 img1 上方； 3、img2 外要有一个盒子，来限制图片的显示范围 添加样式1234567891011121314151617181920212223242526#sp1&#123; width: 6rem; height: 4rem; background: rgba(62,54,58,.4); position: absolute; left: 0; top: 0;&#125;#img1&#123; width: 36rem; height: 22.5rem;&#125;#img2&#123; width: 288rem; height: 180rem; position: absolute;&#125;#box&#123; width: 48rem; height: 32rem; position: absolute; left: 37rem; top: 0; overflow: hidden; display: none; &#125; 1、单位使用 rem，基础长度为 10px； 2、上面说过 box 的作用是限制 img2 的显示范围，overflow: hidden; 使超出 box 大小的部分隐藏； 3、页面中一共有四个“盒子”，分别为 img1、img2、sp1 和 box。他们的尺寸要有一定的关系，后面再说，你可以先大致设置一下。 JS部分1234567891011121314151617181920212223242526272829var img1 = document.getElementById('img1');var sp1 = document.getElementById('sp1');var oBox = document.getElementById('box');var img2 = document.getElementById('img2');sp1.onmouseover = function()&#123; oBox.style.display = 'block';&#125;sp1.onmouseout = function()&#123; oBox.style.display = 'none';&#125;document.onmousemove = function(evt)&#123; var event = evt || window.event; var x = event.clientX - sp1.offsetWidth / 2; var y = event.clientY - sp1.offsetHeight / 2; if(x &lt; 0)&#123; x = 0 &#125; if(y &lt; 0)&#123; y = 0 &#125; if(x &gt; img1.offsetWidth - sp1.offsetWidth)&#123; x = img1.offsetWidth - sp1.offsetWidth; &#125; if(y &gt; img1.offsetHeight - sp1.offsetHeight)&#123; y = img1.offsetHeight - sp1.offsetHeight; &#125; if(event.clientX &lt; img1.offsetWidth &amp;&amp; event.clientY &lt; img1.offsetHeight)&#123; sp1.style.left = x + 'px'; sp1.style.top = y + 'px'; img2.style.left = -x * (img2.offsetWidth / img1.offsetWidth) + 'px'; img2.style.top = -y * (img2.offsetHeight / img1.offsetHeight) + 'px'; &#125;&#125; 1、首先获取页面中的四个“盒子”; 2、前面分析过，img2 只有在鼠标放在 “选择框” （即 sp1）上时才能显示，123456sp1.onmouseover = function()&#123; oBox.style.display = 'block';&#125;sp1.onmouseout = function()&#123; oBox.style.display = 'none';&#125; 这个应该都能明白。。 3、x 和 y 是我们用来设定选择框的 left 和 top 值的，event.clientX、event.clientY 获取当前鼠标的坐标，在减去选择框自身的一般即为选择框左上角应该的坐标值。12var x = event.clientX - sp1.offsetWidth / 2;var y = event.clientY - sp1.offsetHeight / 2; 4、再来考虑这个选择框应该在 img1 上，而不能跑出去，所以我们要对 x 和 y 做一些限制，12345678if(x &lt; 0)&#123; x = 0 &#125; //左侧if(y &lt; 0)&#123; y = 0 &#125; //上侧if(x &gt; img1.offsetWidth - sp1.offsetWidth)&#123; //右侧 x = img1.offsetWidth - sp1.offsetWidth;&#125;if(y &gt; img1.offsetHeight - sp1.offsetHeight)&#123; //下侧 y = img1.offsetHeight - sp1.offsetHeight;&#125; 5、选择框要跟随着鼠标移动，准确来说应该是当鼠标移入 img1 后，选择框要跟着鼠标移动。1234if(event.clientX &lt; img1.offsetWidth &amp;&amp; event.clientY &lt; img1.offsetHeight)&#123; sp1.style.left = x + 'px'; sp1.style.top = y + 'px';&#125; 6、当选择框的 left 和 top 值确定了，我们是不是只要考虑选择框和 img2 之间的关系就可以确定 img2 的 left 和 top了。 页面中四个盒子的尺寸要满足这样的关系：sp1/img1 = box/img2，这样才能使 选择框 相当 于box。你可以仔细理解一下这句话，其实就是一种比例关系。 可以回头重新设置他们四个的尺寸。。 到此，这个效果全部实现了。。。 文章中如果有错误欢迎指出，非常乐意和大家一起交流。完整代码可到 JavaScript-Programs 下载]]></content>
      <categories>
        <category>每周JS小程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04 TeleGrav 重力球]]></title>
    <url>%2F2017%2F05%2F16%2F04---TeleGrav-%E9%87%8D%E5%8A%9B%E7%90%83%2F</url>
    <content type="text"><![CDATA[第四周，做一个可以随便扔的重力球。 效果预览 思路分析1、首先我们得做一个小球，并且能使用鼠标控制（也就是拖拽功能） 2、小球在页面中反弹的效果我们可以用一个定时器不断的计算小球的 left 和 top 值来实现。 先实现拖拽功能以正方形来了解一下拖拽的原理，希望自己能说清楚吧。在屏幕上放下一个正方形12345678910111213&lt;div id="box"&gt;&lt;/div&gt;html,body&#123; margin: 0; padding: 0;&#125;#box&#123; width: 100px; height: 100px; background: #f00; position: absolute; left: 0; top: 0;&#125; 先给上代码，然后在细说12345678910111213141516171819202122232425262728293031var oBox = document.getElementById('box');oBox.onmousedown = function(evt)&#123; var oEvent = evt || window.event; var iLeft = oEvent.offsetX; var iTop = oEvent.offsetY; maxL = document.documentElement.clientWidth - oBox.offsetWidth, maxT = document.documentElement.clientHeight - oBox.offsetHeight; document.onmousemove = function(evt)&#123; var oEvent = evt || window.event; var left = oEvent.clientX - iLeft; var top = oEvent.clientY - iTop; if(left &lt;= 0) &#123;left = 0&#125; if(top &lt;= 0) &#123;top = 0&#125; if(left &gt;= maxL) &#123;left = maxL&#125; if(top &gt;= maxT) &#123;top = maxT&#125; oBox.style.left = left+'px'; oBox.style.top = top+'px'; speedX = left - lastX; speedY = top - lastY; lastX = left; lastY = top; //这四个值后面会用到，拖拽里没有用到 &#125; document.onmouseup = function()&#123; document.onmousemove = null; &#125;&#125; 1、maxL 和 maxT 前面没有 var 是因为声明一个全局变量，后面还要用。 2、event 是一个事件对象。可以通过这个事件对象获得一些信息：导致事件的元素、事件的类型等。Chrome、FF等浏览器中可以直接获得这个对象，IE 中要用 window.event 获得，所以做一下兼容。 3、oEvent.offsetX 和 oEvent.offsetY 用来获取点击 box 时鼠标指针的位置距离 距离 box 左侧和顶部的距离。如下图： 4、得到上面的距离后，我们就可以间接计算出 box 左上角距离浏览器左上角的距离。即:12left = event1.clientX - event2.offsetX;top = event1.clientY - event2.offsetY; 5、注意： event1 指的是 document 对象，event2 指的是 box 对象。所以不能这样写：12var left = oEvent.clientX - oEvent.offsetX;var top = oEvent.clientY - oEvent.offsetY; 同样也不能使用 oBox.offsetLeft 直接得到 box 左上角距离浏览器左侧的距离，因为这是个定值，永远不会改变。 6、实际上我们得到的 left 和 top 画出了 box 左上角可变化的范围，如下图所示： 所以我们要判断当前 left 和 top 是否超出了这个范围：1234if(left &lt;= 0) &#123;left = 0&#125;if(top &lt;= 0) &#123;top = 0&#125;if(left &gt;= maxL) &#123;left = maxL&#125;if(top &gt;= maxT) &#123;top = maxT&#125; 7、最后把最后的 left 和 top 应用给 box：12oBox.style.left = left+&apos;px&apos;;oBox.style.top = top+&apos;px&apos;; 8、鼠标松开后，将 onmousemove 事件移除123document.onmouseup = function()&#123; document.onmousemove = null;&#125; 效果： 这就是拖拽，这么分析下来也是挺简单的。 9、还有一点，要把这个正方形变成一个小球，很简单：123#box&#123; border-radius: 50%;&#125; 接着昨天的往下讲。。。。（说好的一天一个小程序呢？？）下面来给小球加上 “重力” 。 何时开始有重力前面说过，我们是通过定时器不断计算小球的 left 和 top 来实现这个反弹效果的。我们来思考一下什么时候触发这个定时器？当页面刷新后，小球在左上角，我们不点击它就不会有任何效果。当我们点击后，还是不应该触发，而是等拖拽动作完成，并且松开鼠标后触发。所以，我们应该这也做：12345678910document.onmouseup = function()&#123; document.onmousemove = null; startMove();&#125;var timer = null;function startMove()&#123; timer = setTimeout(function()&#123; .... &#125;,16);&#125; 1、startMove() 是我们用来给小球添加“重力”的函数。结构就是这样。 “重力”先给上代码吧，这样讲解比较方便1234567891011121314151617181920212223242526272829303132333435363738var timer = null;function startMove() &#123; var nowX = oBox.offsetLeft; var nowY = oBox.offsetTop; clearInterval(timer); //清除定时器，这个是避免和上一次冲突 timer = setInterval(function() &#123; speedY += 2; nowX += speedX; if (nowX &gt; maxL) &#123; speedX *= -0.8; nowX = maxL; &#125; else if (nowX &lt; 0) &#123; speedX *= -0.8; nowX=0; &#125; nowY += speedY; if (nowY &gt; maxT) &#123; speedY *= -0.8; speedX *= 0.8 nowY = maxT; &#125; else if (nowY &lt; 0) &#123; speedY *= -1; speedX *= 0.8; nowY = 0; &#125; if (Math.abs(speedX) &lt; 1) &#123; speedX = 0; &#125; if (Math.abs(speedY) &lt; 1) &#123; speedY = 0; &#125; if (speedX == 0 &amp;&amp; speedY == 0 &amp;&amp; nowY == maxT) &#123; clearInterval(timer); &#125; oBox.style.left = nowX + 'px'; oBox.style.top = nowY + 'px'; &#125;, 25)&#125; 1、首先 var nowX = oBox.offsetLeft;var nowY = oBox.offsetTop;获取 box 当前的坐标（被拖拽后）。 2、定时器为什么要选择 16 秒？因为肉眼可识别的帧率是60帧，所以每 16ms 改变一次小球的位置我们看起来就是连续的动画。 3、还记得拖拽中的那四个变量吗？分别是：lastX、lastY记录上一次拖拽 box 的坐标； speedX、speedY这次拖拽后 box 的坐标相对上次的变化量。 4、假如第一次 box 在 box1 处，拖拽后在 box2 处。则lastX = a;lastY = c; speedX = b - a;speedY = d - c; 5、你可以把 speedX 、speedY 理解为鼠标拖动小球走的速度。因为执行一次循环的时间是一定的（16ms），这个值越大，说明鼠标移动的越快。同时也是每次执行定时器 box 的 left 或 top 的改变量。12nowX += speedX;nowY += speedY; 6、值得注意的是：当没有触碰到边界时，nowX 和 nowY 的改变量是不会改变的。只有当触碰到边界时，这个值才会 *0.8 || *-0.8 。123456789101112131415161718192021nowX += speedX;//判断 box 是否超出了 可移动范围；if (nowX &gt; maxL) &#123; speedX *= -0.8; //反向 //alert(speedX); nowX = maxL;&#125; else if (nowX &lt; 0) &#123; //判断是否碰到左侧 speedX *= -0.8; //反向 nowX = 0; //迅速移入屏幕&#125;nowY += speedY;if (nowY &gt; maxT) &#123; speedY *= -0.8; //speedX *= 0.8 nowY = maxT;&#125; else if (nowY &lt; 0) &#123; speedY *= -1; //speedX *= 0.8; nowY = 0;&#125; 7、那为什么小球 X 方向反弹一次就会慢慢停下来？？这是因为 Y 方向碰到边界也会使 speedX 衰减（注意看代码）。也就是说 横向的碰撞只影响 speedX，纵向的碰撞即改变横向也改变纵向。你可以这样做试一试：12345678910nowY += speedY;if (nowY &gt; maxT) &#123; speedY *= -0.8; //speedX *= 0.8 nowY = maxT;&#125; else if (nowY &lt; 0) &#123; speedY *= -1; //speedX *= 0.8; nowY = 0;&#125; 小球 X 方向需要碰撞很多次才能停下来。 8、最后判断 speedX 和 speedY 的绝对值如果小于 1 。这个该变量完全可以忽略了没就让小球停下来。123if (speedX == 0 &amp;&amp; speedY == 0 &amp;&amp; nowY == maxT) &#123; clearInterval(timer);&#125; 基本的原理都讲完了，里面还有一些细节需要注意，比如说：何时清除定时器、作用域等问题。都是很基础的知识，就不说了。 终于讲完了，，里面也有许多不完美的地方，以后有时间在改吧！！ 文章中如果有错误欢迎指出，非常乐意和大家一起交流。完整代码可到 JavaScript-Programs 下载]]></content>
      <categories>
        <category>每周JS小程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03 Typewriter 打字机特效]]></title>
    <url>%2F2017%2F05%2F09%2F03---Typewriter-%E6%89%93%E5%AD%97%E6%9C%BA%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[第三周，来做一个有关文字的特效吧！不知道该取什么合适的名字，索性就叫做 typewriter (打字机) 吧！ 实现效果： 思路1、把要显示的文字放在一个容器中，做好样式并放在合适的位置；2、提取这个容器中的文本内容；3、把获取到的文本拆分成一个个字符串，逐个显示。 原理貌似很简单，来实现一下看会遇到什么问题。 HTML&amp;CSS准备要显示的文字随便找了几句话比较喜欢的话。就这样放在页面中了：1234567891. Whatever is worth doing is worth doing well.&lt;br /&gt; 任何值得做的，就把它做好。&lt;br /&gt;&lt;br /&gt;2. Happiness is a way station between too much and too little.&lt;br /&gt; 幸福是太多和太少之间的一站。&lt;br /&gt;&lt;br /&gt;3. In love folly is always sweet.&lt;br /&gt; 恋爱中，干傻事总是让人感到十分美妙。&lt;br /&gt;&lt;br /&gt;4. Your happy passer-by all knows, my distressed there is no place hides.&lt;br /&gt; 你的幸福路人皆知，我的狼狈无处遁形。&lt;br /&gt;&lt;br /&gt;5. You may be out of my sight, but never out of my mind.&lt;br /&gt; 你也许已走出我的视线，但从未走出我的思念。 加些简单的样式：123456789.typewriter&#123; width: 50rem; padding: 1.5rem 3rem; border: 1px solid #ccc; line-height: 1.5; font-size: 1.6rem; color: #333; margin: 5% auto;&#125; 整个文本外有一个边框，放在了页面的中心位置。 需要一个光标通过 伪元素 来实现这个光标。123456789101112131415@keyframes flash &#123; 0%&#123; visibility: visible; &#125; 100%&#123; visibility: hidden; &#125;&#125;.typewriter:after&#123; content: '_'; animation: flash .6s steps(2,start) infinite;&#125;.typewriter.gameover:after &#123; display: none;&#125; 1、光标就长这个样子 content:&#39;_&#39;; 吧！ 2、使用 @keyframes 关键字定义一个动画，效果为从 显示 状态 过度到 隐藏 状态。 3、 animation 属性为光标应用一个动画。动画的名称为 flash、这个动画要在 0.6s 完成、动画过渡类型 和 执行次数（infinite为无限循环） 4、.typewriter.gameover:after{} 当文字全部显示完毕后，将光标隐藏。 JS部分获取文本内容获取整个 typewriter 容器中的文本，将其保存在变量 code 中。12var typewriter = document.querySelector('.typewriter');var code = typewriter.innerHTML; 既然文本已经保存了起来，那么页面中的文本就可以隐藏（或者删除）了。因为我们最后的效果是 从无到有。1typewriter.innerHTML = ''; 这时你会发现一个问题，我们保存在 code 中的内容是这样的： 里面包含了 HTML 字符，而这些 HTML 字符是不需要显示的，所以打印的时候要对字符进行判断，跳过 &lt;...&gt; 和 &amp;...; 这一部分。 我们用一个函数来实现这个过程：12345678910111213141516171819var i = 0;function typewriting()&#123; i++; if(i &lt; code.length)&#123; switch (code.charAt(i))&#123; case '&lt;': i = code.indexOf('&gt;',i); break; case '&amp;': i = indexOf(';',i); break; &#125; typewriter.innerHTML = code.substring(0,i); setTimeout(typewriting,100); &#125; else&#123; typewriter.classList.add('gameover'); &#125;&#125; 1、三个操作字符串的方法：charAt() 方法可返回指定位置的字符indexOf() 方法返回某个指定字符在字符串中首次出现的位置。substring() 方法用于提取字符串中介于两个指定下标之间的字符。 2、 typewriter.innerHTML = code.substring(0,i); 将 code 中保存的字符的 0 ~ i 打印出来。 注： 每次执行循环其实都是从 0 ~ i 打印一遍，只不过从 0 ~ i-1 已经存在，再视觉上就被认为只打印了第 i 个字符 3、switch 语句判断第 i 个字符是否为 &lt; 或 &amp;？如果是其中之一，则从这个字符开始往后寻找 &gt; 或 ;，找到后将其 i 值赋给 i （这时的 code[i] 已经是 &lt;br&gt; 或 之后的那个字符）。也就是打印跳过了 `&lt;br&gt;` 或 。 感觉自己说不明白了，还是举个例子吧！假如 code = &#39;ab&lt;br&gt;cd&#39;;当第一次循环，打印出 a、第二次循环打印出 ab 、第三次循环打印出 ab&lt;br&gt;c（虽然被打印出来了，但是不会显示的，所以你只看到打印出来了 c） 、第四次循环打印出 ab&lt;br&gt;cd。 4、 setTimeout() 定时器，每隔 100ms 执行一次这个循环，也就是控制打印的速度。 5、 当 i &gt; code.length 时，给光标添加 .gameover 样式，将其隐藏。 到此这个效果全部实现！！ 文章中如果有错误欢迎指出，非常乐意和大家一起交流。完整代码可到 JavaScript-Programs 下载]]></content>
      <categories>
        <category>每周JS小程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如果一个吻是一滴水，我给你整个大海]]></title>
    <url>%2F2017%2F05%2F07%2F%E6%97%A0%E5%90%8D%E8%AF%97%2F</url>
    <content type="text"><![CDATA[在网上看到的一首诗，简单的言语却无比动人。可惜没有作者，也没有标题。 People live people diePeople laugh people crySome give up some will trySome say hi some say byeSome may forget you but never will I Feel good when somebody misses youFeel better when somebody loves youBut feel best when somebody never forgets you Flowers need sunshineViolets need dewAll Angels in heaven know I need youYears may flyTears may dryBut my friendship with you will never die If kisses were waterI will give you seaIf kisses were leavesI will give you a treeIf you love planetI will give you a galaxyIf friendship were life I will give you mine In my life I learned how to love to smile to be happy to be strong to work hard to be honest to be faithful to forgiveBut I couldn’t learn how to stop remembering you There are many stars but the moon is youThere are many friends but the best is youTo forget me that’s up to youTo forget you I will never ever do You may be out of my sight but not out of my heartYou may be out of my reach but not out of my mindI may mean nothing to you but you will always be special to me!]]></content>
      <categories>
        <category>文学爱好者</category>
      </categories>
      <tags>
        <tag>英文</tag>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 Clock-ISO 时钟]]></title>
    <url>%2F2017%2F05%2F03%2F02---Clock-ISO%E6%97%B6%E9%92%9F%2F</url>
    <content type="text"><![CDATA[第二周，我们来模仿一个 ISO 上的时钟：ISO Clock 实现效果： 项目分析1、首先时钟嘛，肯定要获取本地客户端的时间； 2、时钟有 3 个指针，我们可以通过添加动画的方式让它们围绕中心点转动； 3、通过获取到的 hour、minute 和 second 值分别计算 时针、分针和秒针的角度值； HTML&amp;CSS布局12345678910111213&lt;div class="box"&gt; &lt;article class="clock"&gt; &lt;div class="hours-container"&gt; &lt;div class="hours"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="minutes-container"&gt; &lt;div class="minutes"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="seconds-container"&gt; &lt;div class="seconds"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; 1、.box 是为了布局的方便； 2、 然后每个指针都需要一个 *-container 容器 。 添加 CSS 样式把背景加载进来，然后放在页面中合适的位置上。12345678910111213141516171819202122232425html&#123; font-size: 10px;&#125;html,body&#123; margin: 0; padding: 0;&#125;.box&#123; width: 35rem; height: 38rem; background: rgb(205,205,205); border-radius: 1rem; margin: 5% auto; display: flex; justify-content: center; align-items: center;&#125;.clock&#123; width: 30rem; height: 30rem; background: #fff url(ios_clock.svg) no-repeat center; background-size: 88%; border-radius: 50%; position: relative;&#125; 1、 width: 35rem; height: 38rem; 这个比例比较顺眼吧； 2、 .box 使用 Flex 布局方式，并且使其中的 .clock 水中、垂直方向都居中。看过第一天教程应该都明白 Flex 布局的。 3、Clock 的背景使用一张图片。获取地址 添加中心轴使用 CSS3 中的 伪元素 为时钟添加实心小圆点，指针都围着这个点转。123456789101112.clock:after&#123; content: ''; width: 1.5rem; height: 1.5rem; background: #000; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); /* 向左上移动自身的50% */ z-index: 10;&#125; 1、 这句 content: &#39;&#39;; 是必须的，不然这个伪元素不会显示，即使指定了宽度和高度。 2、 由于相对定位是从元素的左上角开始计算的，所以 top: 50%; left: 50%; 不能使这个小圆点在 Clock 的中心，使用 transform: translate(-50%,-50%); 向左上方移动自身宽度或高度的 50% 3、 z-index: 10; 是为了使这个小圆点在视图的最上层，遮挡住指针交叉的地方 指针容器1234567.hours-container,.minutes-container,.seconds-container&#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0;&#125; 1、容器被放置在 Clock 的上方，但是并没有样式，接下来就可以创建指针了！ 添加指针12345678910111213141516171819202122232425262728.hours &#123; width: 3%; height: 20%; background: #000; transform-origin: 50% 100%; position: absolute; top: 30%; left: 48.5%;&#125;.minutes &#123; width: 2%; height: 37%; background: #000; transform-origin: 50% 100%; position: absolute; top: 13%; left: 49%;&#125;.seconds &#123; width: 1%; height: 40%; background: #f00; transform-origin: 50% 90%; position: absolute; top: 20%; left: 49.5%; z-index: 8;&#125; 1、分别添加时针、分针和秒针。 2、 使用 % 这种单位可以更好地适应不同的屏幕。 3、transform-origin: 50% 90%; 规定指针旋转的位置为：X 方向的中心线 和 Y 方向的 90% 处这条线的交叉点。（具体看图吧） 4、 这里在定位的时候把自身的宽度计算在内了，所以就不必在往左上角移动了。 动画目前为止，这个 Clock 还是没有功能的，我们来让它动起来。 定义动画规则12345@keyframes rotate &#123; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 1、这里用 @keyframes 规则定义了一个动画，这个动画的名称是 ratate ,应用这个动画的元素会沿着某个 Z 轴（也就是上面规定好的哪个交叉点）旋转 360 度。 定时功能规定每个指针旋转 360 度需要多长时间。123456789.hours-container &#123; animation: rotate 60s infinite linear;&#125;.minutes-container &#123; animation: rotate 30s infinite linear;&#125;.seconds-container &#123; animation: rotate 10s infinite linear;&#125; 为了演示方便，这里固定的时间并没有按照真实的 Clock 来设置。时针应该是 12 小时（43200s）、分针应该是 3600s 、秒针应该是 60s 。 更像真实的 Clock现实中的 Clock 大部分是秒针和分针都是会跳动的，并且伴随着滴答声，我们来尝试一下。123456789.hours-container &#123; animation: rotate 60s infinite linear;&#125;.minutes-container &#123; animation: rotate 3600s infinite steps(60);&#125;.seconds-container &#123; animation: rotate 60s infinite steps(60);&#125; 1、只需要将 分针 和 秒针的旋转方式调整为 steps() 即可。 但是这样的 Clock 每次刷新都是从 0 开始的，并不是我们需要的，怎么做一个显示真实时间的呢？？ 正确的时间我们首先要获取到当前的时间，然后计算每个指针应该旋转的角度即可。 获取每个指针123const hourHand = document.querySelector(&apos;.hours-container&apos;);const minuteHand = document.querySelector(&apos;.minutes-container&apos;);const secondHand = document.querySelector(&apos;.seconds-container&apos;); 获取当前时间1234const now = new Date();const hour = now.getHours();const minute = now.getMinutes();const second = now.getSeconds(); 计算每个指针应旋转的角度在 CSS3 中角度单位一共有四种： deg (度，一个圆 360 度)、 grad（梯度，一个圆共400梯度）、 turn （转、圈，一个圆共1圈）、 rad （弧度，一个圆共2π弧度） 它们的对应关系为：90deg = 100grad = 0.25turn ≈ 1.570796326794897rad 很显然，我们这里要用到的单位是 deg 。123const secondDegree = second * 6 + 90;const minuteDegree = minute * 6 + (second / 10) + 90;const hourDegree = (hour * 30) + (minute / 2) + 90; 1、+90 是因为角度的起始位置为水平的 X 轴，为了和 Clock 指针起始位置（Y 轴）做统一； 2、秒针的计算最简单，(second / 60) * 360 + 90; 3、 分针要考虑秒针的影响，如过了30秒，相当于半分钟。公式为： 当前分钟数 + 秒数在分钟的映射；即：(( minutes/ 60) * 360) + ((seconds / 60) * 6) + 90; 4、 时针稍微复杂一点，因为要考虑分钟的影响，如过了30分钟，相当于半小时。公式为： 当前时数 + 分钟在小时的映射 。即：(( hours/ 12) * 360) + ((minutes / 60) * 30) + 90; 应用角度值123hourHand.style.transform = `rotateZ($&#123;hourDegree&#125;deg)`;minuteHand.style.transform = `rotateZ($&#123;minuteDegree&#125;deg)`;secondHand.style.transform = `rotateZ($&#123;secondDegree&#125;deg)`; 为了使页面能实时的更新，我们要把上面的这些东西封装为一个函数，然后用定时器每秒执行一次。 整个时钟的功能都完成了！ 文章中如果有错误欢迎指出，非常乐意和大家一起交流。完整代码可到 JavaScript-Programs 下载]]></content>
      <categories>
        <category>每周JS小程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 Drun-Kit 爵士鼓]]></title>
    <url>%2F2017%2F04%2F26%2F01---Drum-Kit-%E7%88%B5%E5%A3%AB%E9%BC%93%2F</url>
    <content type="text"><![CDATA[第一周，我们做一个爵士鼓小特效：Drum Kit 。 实现效果模拟一个爵士鼓的效果，通过敲击键盘上不同的字母，发出不同的声音，并且页面上产生伴随着敲击的动画。 项目分析1、通过键盘事件监听用户按下了哪个键。为了效果更好选择使用 keydown 事件（按下键的一瞬间就做出响应）； 2、播放音频：用户按下按键时播放音频，用到了 video.play()； 3、添加样式：用户按下按键时给相应 DOM 添加 CSS样式，Element.classList.add(&#39;className&#39;) 4、移除样式：用户松开按键时把样式移除，Element.classList.remove(&#39;className&#39;) 原理貌似很简单，现在动手来实现一下。 HTML&amp;CSS创建页面布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div class="keys"&gt; &lt;div data-key="65" class="key"&gt; &lt;kbd&gt;A&lt;/kbd&gt; &lt;span class="sound"&gt;clap&lt;/span&gt; &lt;/div&gt; &lt;div data-key="83" class="key"&gt; &lt;kbd&gt;S&lt;/kbd&gt; &lt;span class="sound"&gt;hihat&lt;/span&gt; &lt;/div&gt; &lt;div data-key="68" class="key"&gt; &lt;kbd&gt;D&lt;/kbd&gt; &lt;span class="sound"&gt;kick&lt;/span&gt; &lt;/div&gt; &lt;div data-key="70" class="key"&gt; &lt;kbd&gt;F&lt;/kbd&gt; &lt;span class="sound"&gt;openhat&lt;/span&gt; &lt;/div&gt; &lt;div data-key="71" class="key"&gt; &lt;kbd&gt;G&lt;/kbd&gt; &lt;span class="sound"&gt;boom&lt;/span&gt; &lt;/div&gt; &lt;div data-key="72" class="key"&gt; &lt;kbd&gt;H&lt;/kbd&gt; &lt;span class="sound"&gt;ride&lt;/span&gt; &lt;/div&gt; &lt;div data-key="74" class="key"&gt; &lt;kbd&gt;J&lt;/kbd&gt; &lt;span class="sound"&gt;snare&lt;/span&gt; &lt;/div&gt; &lt;div data-key="75" class="key"&gt; &lt;kbd&gt;K&lt;/kbd&gt; &lt;span class="sound"&gt;tom&lt;/span&gt; &lt;/div&gt; &lt;div data-key="76" class="key"&gt; &lt;kbd&gt;L&lt;/kbd&gt; &lt;span class="sound"&gt;tink&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;audio data-key="65" src="sounds/clap.wav"&gt;&lt;/audio&gt; &lt;audio data-key="83" src="sounds/hihat.wav"&gt;&lt;/audio&gt; &lt;audio data-key="68" src="sounds/kick.wav"&gt;&lt;/audio&gt; &lt;audio data-key="70" src="sounds/openhat.wav"&gt;&lt;/audio&gt; &lt;audio data-key="71" src="sounds/boom.wav"&gt;&lt;/audio&gt; &lt;audio data-key="72" src="sounds/ride.wav"&gt;&lt;/audio&gt; &lt;audio data-key="74" src="sounds/snare.wav"&gt;&lt;/audio&gt; &lt;audio data-key="75" src="sounds/tom.wav"&gt;&lt;/audio&gt; &lt;audio data-key="76" src="sounds/tink.wav"&gt;&lt;/audio&gt; 1、date-* 是 HTML5 中新增的自定义属性功能. 通过 data-key 可以将页面中的 DOM 和 audio 关联起来。 添加样式12345678910111213141516171819202122232425262728293031323334353637383940414243html&#123; font-size: 10px;&#125;html,body&#123; margin: 0; padding: 0;&#125;.keys&#123; display: flex; flex: 1; align-items: center; justify-content: center; min-height: 100vh; text-shadow: 0 0 .5rem #000;&#125;.key&#123; width: 10rem; padding: 1rem .5rem; margin: 1rem; border: .4rem solid #000; border-radius: .5rem; font-size: 1.5rem; text-align: center; color: #fff; background: rgba(0,0,0,.4); transition: all .07s ease; //动画的过度时间和方式&#125;kbd&#123; display: block; font-size: 4rem;&#125;.sound&#123; font-size: 1.2rem; color: #ffc600; letter-spacing: .1rem; text-transform: uppercase; //文字转换为大写&#125; .playing &#123; transform: scale(1.1); border-color: #ffc600; box-shadow: 0 0 1rem #ffc600;&#125; 1、 使用了 flex 布局（CSS3中的布局方式）。如果你还不知道这种布局方式可以去看一下我的这两篇文章：Flex布局教程 - 语法篇Flex布局教程 - 常用Flex布局的写法 2、 定义 .palying 类，在按键按下的时侯为该元素添加 playing 类，结束后将其移除。 3、 transform: scale(1.1) 将元素缩放为原来的 1.1 倍； 4、 transition: all .07s ease; 使整个动画过程在 0.07 秒内完成。 JS部分按键监听 &amp; 播放音频 &amp; 添加动画12345678910111213 function playAudio(event)&#123; var num = event.keyCode; const audio = document.querySelector(`audio[data-key="$&#123;num&#125;"]`); if(!audio) return; const key = document.querySelector(`div[data-key="$&#123;num&#125;"]`); if(!key) return; audio.currentTime = 0; audio.play(); key.classList.add('playing'); &#125;//给页面添加键盘事件 window.addEventListener('keydown',playAudio); 1、监听页面的 keydown 事件，触发 playAudio() 函数。 2、每一个按键都有自己的键码 KeyCode，可以通过按键的 keyCode 来判断被按下的是哪个键。如果不清楚每一个按键的 keyCode 是多少，可以访问 这个网站 。 3、获取到 keyCode 并赋值给 num 。然后我们用到了 ES6 的模板字符串，${num}，可以动态的将按键的 Keycode 传过去，以使 audio 动态的获取每一个按键绑定的 DOM 和 audio。 需要注意的是模板字符串一定要使用 “`” (Esc下面那个键)包裹，而不是双引号。 4、我们注意到 audio.play(); 前面一行是 audio.currentTime = 0;，这是为了解决，当我连续点击某一按键（或者按住按键不放）的时候，只有第一次点击会响，第二次第三次连续的点击可能没声音。所以在每一次点击之前 重置音效 是很有必要的。 5、key.classList.add(&#39;playing&#39;); 可以在按键点击的同时为该元素添加playing 类，展示小动画。 6、if(!audio) return; if(!key) return; 因为并不是每一个按键都有音效，当用户点击了非绑定音效按键，及时退出函数是很好的习惯，避免内存浪费。 移除动画12345function remove(event) &#123; this.classList.remove('playing'); &#125; var keys = document.querySelectorAll('.key'); keys.forEach(key =&gt; key.addEventListener('transitionend', remove)); 1、监听每一个按键元素的 transitionend 事件，当按键元素的动画结束后会触发 remove() 函数。注意： transitionend 事件会在CSS中的 transition: all .07s ease; 动画执行完毕后触发。 2、在定位元素的时候，可以使用 this 也可以使用 e.target ,可以简单这么理解，this 值的是谁出发了这次事件，也就是 key，就等同于事件的目标 e.target. 3、使用 document.querySelector 获取一组符合 CSS 选择符的元素快照，类型为 NodeList（此对象是对于文档的实时运行的动态查询），使用 forEach() 对其进行遍历。 到此，全部效果都实现了！！ 文章中如果有错误欢迎指出，非常乐意和大家一起交流。完整代码可到 JavaScript-Programs 下载]]></content>
      <categories>
        <category>每周JS小程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】每周一个JS小程序]]></title>
    <url>%2F2017%2F04%2F25%2F%E6%AF%8F%E5%91%A8%E4%B8%80%E4%B8%AAJS%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[给自己提出一个挑战。用原生 JavaScript 来写东西，不借助框架和库，也不使用编译器和引用。每周更新 主要写一些小程序，每个程序都会给出清晰的思路和代码实现过程，尽量让每个初学者都能看懂（不出意外的话每周都会更新）。 Github地址： cwyaml/JavaScript-Programs如果喜欢的话 请给个 ★star 非常感谢！！ 项目目录：[2017-04-26] – 01- JavaScript Drum Kit 爵士鼓[2017-05-03] – 02 - JavaScript&amp;CSS Clock IOS时钟[2017-05-09] – 03 - Typewriter 打字机特效[2017-05-16] – 04 - TeleGrav 重力球[2017-05-21] – 05 - Magnifier 放大镜[2017-05-29] – 06 - The Matrix 黑客帝国特效[2017-06-04] – 07 - Barrage 弹幕实现原理[2017-06-15] – 08 - Variables CSS变量[2017-06-23] – 09 - 做个音乐播放器[2017-06-30] – 10 - 图片 Base64 编码]]></content>
      <categories>
        <category>每周JS小程序</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局介绍]]></title>
    <url>%2F2017%2F04%2F18%2FFlex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[网页布局（layout）是CSS的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex布局是什么？Flex 是 Flexible Box 的缩写，意为“弹性布局”，用来为盒状模型那个最大的灵活性。 任何一个容器都可以指定为 Flex 布局。123.box&#123; display: flex;&#125; 包括行内元素也可以123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器最好加上 -webkit 前缀。1234.box&#123; display: flex; display: -webkit-flex;&#125; 注意： 设置为 Flex 布局后所有子元素的 float、clean 和 vertical-align 属性都将失效 基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称“容器”。它的所有子元素自动成为容器的成员，成为 Flex 项目（flex item），简称“项目”。 容器默认存在两根轴：水平主轴（main axis） 和 垂直的交叉轴（cross axis）。 主轴开始的位置叫做 main start，结束的位置叫做 main end;教学和周开始的位置叫做 cross start，结束的位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。 容器的属性容器的属性一共有 6 个： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性flex-direction 属性决定主轴的方向（即项目的排列方向） 可能的值有 4 个：123.box&#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性flex-wrap 属性定义如果再一条轴线上排不下，如何换行。（默认情况下，项目都会排在一条轴线上） 可能的值有 3 个：123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap（默认）不换行 wrap 换行，第一行在上方 wrap-reverse 换行，第一行在下方 flex-flow属性flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式。默认值为 row nowrap。123.box&#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content 属性定义了项目在主轴上的对其方式。123.box&#123; justify-content: flex-start | flex-end | center | space-between | space-around&#125; 可取的值有 5 个： flex-start： （默认值）左对齐 flex-end： 右对齐 center： 居中 space-between： 两端对齐，项目之间的间隔都相等 space-around： 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义项目在交叉轴上如何对齐123.box&#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 可以取 5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start： 交叉轴的起点对齐 flex-end： 交叉轴的终点对齐 center： 价差周的中心对齐 baseline： 项目的第一行文字的基线对齐 stretch： （默认值）如果项目未设置高度或设为 auto ，将占满整个容器的高度 align-content属性align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性将不起作用。123.box&#123; align-content: flex-start | flex-end | center space-between | space-around | stretch;&#125; 该属性可取 6 个值 flex-start： 与交叉轴的起点对齐 flex-end： 与交叉轴的终点对齐 center： 与交叉轴的中心对齐 space-between： 与交叉轴两端对齐，轴线之间的间隔平均分配 space-around： 每根轴线两侧的间隔都相等。所以，轴线之间的间隔与轴线与边框的间隔大一倍。 stretch： （默认值） 轴线占满整个交叉轴 项目属性以下 6 个属性设置在项目上： order flex-grow flex-shrink flex-basis flex align-self order属性order 属性定义项目的排列顺序。数值越小，排列越靠前。默认都为 0 。123.item&#123; order: &lt;integer&gt;&#125; flex-grow属性flex-grow 属性定义项目的放大比例，默认为 0 （即不放大）123.item&#123; flex-grow: &lt;number&gt;;&#125; 如果所有项目的 flex-grow 属性都为 1 ，则他们将等分等于空间（如果有的话）。如果一个项目的 flex-grow 属性为 2，其他项目都是 1，则前者将占据的剩余空间将比其他项目多一倍。 flex-shrink属性flex-shrink 属性定义了项目的缩小比例，默认为 1。（即如果空间不足，则该项目将缩小）12345678910111213141516.item&#123; flex-shrink: &lt;number&gt;;&#125;``` ![flex-shrink](http://upload-images.jianshu.io/upload_images/4030390-df475b8e8539f937.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)如果所有项目的 `flex-shrink` 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 `flex-shrink` 属性为 0，其他项目都为 1，则空间不足是，前者不缩小。**注意：** 负值对该属性无效###flex-basis属性`flex-basis` 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。他的默认值为 `auto`。（即项目本来的大小）``` css.item&#123; flex-basis: &lt;length&gt; | auto;&#125; 它可以设为跟 width 或 height 属性一样的值，则项目将占据固定的空间。 flex属性flex 属性是 flex-grow、flex-shrink 和 flex-basis 的简写，默认为 0 1 auto。后两个属性可选。123.item&#123; flex: none | [&lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt;?]&#125; 该属性有两个快捷键： auto(1 1 auto) 和 none(0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto ,表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。123.item&#123; algin-self: auto | flex-start | flex-end | center | baseling | stretch;&#125; 该属性可取 6 个值，除了 auto 外都与 align-items 属性完全一致。]]></content>
      <categories>
        <category>前端杂货铺</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>Flex</tag>
        <tag>网页布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】技术的边界 - ruanyf]]></title>
    <url>%2F2017%2F04%2F06%2F%E8%BD%AC1%2F</url>
    <content type="text"><![CDATA[去年，网上流传一则趣闻：美国圣昆廷州立监狱安排囚犯学习编程，完成学习的犯人出狱后，没有一个人重新犯罪被抓回监狱。一位刚刚出狱的囚犯说：”太可怕了，我宁愿在外面饿死也不想再进去学编程了。”后面那句话是网友杜撰的，但是程序员圈子里，大家依然把它当作笑话转发。”你看，编程多痛苦，还不如坐牢呢。” 我一直忘不了这个段子，觉得它是一个很好的象征：当代社会就像一座机器组成的监狱，学会技术可以摆脱牢房。 人类已经不再生活在大自然了，而是生活在一种机器环境：住宅、交通、医疗、食物……就连水和空气都是机器提供的。如果机器出故障，人类顿时就有危机。就像病人依赖呼吸机和心脏起博器，人类也依赖着机器。整个社会已经机器化了。 这没有问题，我们理应享受技术成果。问题是，技术正变得越来越先进，也越来越难懂，大多数人已经不能够理解技术了。多少人能说清，手机通信的原理是什么：为什么对着空气发送信号，就能被几千公里以外的另一个人实时收到，而不会发错对象？或者，为什么扫描枪扫一下手机二维码，你的资金就转到了商家的账上？我们已经不懂了，技术如何达成这一切。我们只是按照别人设计好的方式，像傻瓜一样地使用它。对于大多数人来说，技术已经成了一种魔法。我们使用技术，然后像看魔法一样，看着机器变出神奇的结果。由于熟视无睹，我们都不感到惊奇了。我们其实已经生活在一个魔法世界里面，享受着各种技术发明，它们的神奇程度是最大胆的想象力都没有预测到的。 小时候，我读过的第一本科幻小说是《小灵通漫游未来》。书里说，未来的人们都带着一种神奇的手表。 “那手表既没有时针、分针、秒针，也没有齿轮和发条，只不过是一块小小的电视荧光屏，上面写着几个数字：”11：23：40”，也就是11时23分40秒，那表示秒的数字在不断变化。当40秒变成60秒时，那23分也一下子变成了24分。我想，居然会有这样奇妙的手表？ “ 这是前一代人想象中的未来，现在看上去显得非常过时。技术的进步速度，远远超过人们的想象。我们生活在一个机器世界里，但又不懂这些机器，这是一种怎样的处境？现在的模式是，我们花钱购买服务，让懂的人或公司来操作和维护机器。但是，如果有一天，你请不到人，或者机器索性坏了，你不就困在了机器组成的监狱里了吗？ 我妈妈刚开始上网时，有一个问题让她很困惑：为什么网站要求输入用户名和密码，这是什么东西？她问我：”用户名就是身份证上的名字吗？密码是不是身份证号？”我跟她解释：”网站通过用户名才能知道你是谁，密码则是为了防止别人冒充你。它们都可以自己设定。”我妈似懂非懂，为什么要自己为自己起名呢……我妈有了用户名以后，可以自己在”某宝”上买东西了。过了一阵子，她来找我，说用户名不管用了。我过去一看，原来她用这个名字在”某东”登录，怎么都登录不上去。她不太明白，为什么在一个网站申请了用户名，到另一个网站就必须再申请一次？ 我有时想，等到了我妈的年龄，我是否也会对那时的新技术一头雾水，像看天书一样，不懂如何使用。现在的大城市，上下班高峰时段，有时你有钱也打不到出租车，必须使用手机 App 才能叫到车。这对于那些不会使用那些 App 叫车的老年人，真是一种磨难。这就是我们所有人的处境：如果你不理解技术，不会使用它，就麻烦了。 我们的社会已经如此依赖技术，为了适应外界，你至少要知道如何使用它。糟糕的是，技术已经变得如此复杂，没有人能够全部搞懂。系统越来越复杂，分工越来越细，一个人已经不可能从头到尾掌握整个系统了。就拿计算机来说，从底层CPU芯片一直到上层的图形界面，中间大概依次有几十层（甚至上百层）的操作接口，要想全部掌握这些层，几乎是不可能的。有人总结过，单单是”网站搜索”这个简单操作，中间就有24个环节。也就是说，你要搞懂这个操作，就有这么多东西要学习。 现在的情况是：没有人能够理解全部的技术，每个人只懂自己的那一小块。根本无法预测和判断，某个领域的技术发展会引起整个系统怎样的变化。五年规划或十年规划，那种整体的准确安排和控制，就更谈不上了。技术已经到了这样一个地步：我们走一步看一步，谁也不知道十年后，技术会突破到什么程度。 技术最终会把人类带到哪里呢？ 我想我们已经完全不知道了。人类一项又一项地发明新技术，对于新技术带来的后果，已经失去了控制，听任它带着我们向前走。 小说《冰与火之歌》里面，寒冷的北方有一道绝境长城。外面就是危险地带，任何人不得跨越。我最近常想，技术有没有边界呢？一旦接近”绝境长城”，我们会自觉停在那里，不再往下发展吗？举例来说，人工智能领域有一个概念，叫做”终极智能”。意思是，当机器的智能达到这种程度时，就不需要人类再做发明创造了，因为机器自己就会发明创造。如果这种”终极智能”真的可能实现，技术要不要去实现它呢？目前来看，技术完全是野蛮生长，没有办法遏制它的发展。哪怕某种技术最终给人类带来毁灭性影响，我们也无能为力。只要技术有能力做到的事情，最终都会做到。人类（严格地说是某些人）最终将拥有可怕的力量。 现在的技术发展，好比随意地往花盆里面扔种子。原意是种花，但是长出来的可能是一棵树，完全超过了花盆的容量。我们能做的，就是看着它长啊长。一旦植物长得太大，超过了花盆所能承受的重量，整个花盆就将倾覆。 最后，我想到了另一个笑话。 一架飞机即将起飞，里面坐的都是各大软件公司的老板。这时，机长问了他们一个问题：如果这架飞机的控制软件是你的公司写的，你还敢坐吗？除了一个人，其他人都表示不敢坐。 唯一那位愿意继续留在飞机上的乘客，机长走到他的面前，钦佩地说：”看来您对自己公司的软件非常有信心。”那位老板摇摇头：”不是啦，我很清楚，如果你们用了我们的软件，这架飞机根本飞不起来。”第一次听到的时候，我的反应是这不是笑话。一架民航客机有100多吨，就悬浮在空中，上不着天，下不着地，机上乘客的性命完全取决于技术，我们其实真的是把生命托付给软件公司。如今，我的这种想法更强烈了。它其实是一个隐喻，整个人类正坐在一架软件驾驶的飞机里面，只能祈祷软件运行永远不发生错误。一旦发生问题，人类就会坠机。 物理学告诉我们，要想让飞机在高空不掉下来，就必须高速前进，不能够失去速度。技术也是如此，为了让现有的技术更可靠，只有发展更先进的技术。人类已经走上了一条无法回头的道路，只能提速，无法减速。 一个依赖技术的高科技、高度自动化的社会，也是一个非常脆弱的社会。有人说，一旦出现危机（比如全球变暖或战争），人类就会减缓（甚至冻结）技术发展的速度。错！危机只会进一步加速技术发展，而不会减缓。技术的危机只能用更好的技术解决，否则人类社会就有立刻崩溃的危险。但是， 高速公路上不能刹车，意味着什么？20世纪初，美国经济学家熊彼特说过一句名言：“资本主义经济最终将因为无法承受其快速膨胀带来的能量，而崩溃于自身的规模。”我觉得，技术可能也是如此，高速发展所蕴含的巨大能量，最终将把人类社会带到难以预测的脆弱状态。 转自 【未来世界的幸存者】——阮一峰]]></content>
      <categories>
        <category>转载优质文章</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>ruanyf</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 域名绑定]]></title>
    <url>%2F2017%2F03%2F09%2Fyuming%2F</url>
    <content type="text"><![CDATA[前面也讲过了，我们把博客同时托管到 Github 和 Coding。我们就有两个域名可以访问站点，但是又出现几个问题：使用的不是自己的域名；两个地址的统计信息（文章阅读量，访问量等）相互独立，不能合并；github pages国内访问速度慢（300ms左右，毕竟国外的服务器）。 这就有点坑爹了，强迫症怎么能忍。下面给出解决方法。。 解决方案：我们知道 github 和 coding 的 pages 服务都提供 自定义域名 功能。我们可以利用这一点，绑定自己的域名。域名解析的时候实现国内访问 coding pages ，国外访问 github pages ,从而加快访问速度。 具体怎么实现，往下看： 购买域名首先我们要购买一个域名，推荐到 万网 购买。（毕竟很方便）具体步骤可以参考这篇文章：万网域名注册教程。 购买域名一定要实名认证，否则会停止解析 域名解析这一步是最重要的，我们要把域名指向 github 和 coding 的服务器空间。1、登录阿里云，进入 控制台 。依次点击 域名与网站 &gt; 云解析DNS 就会出现你购买的域名信息 2、点击 解析，然后按照下图依次添加解析：（这张图片可以放大） 从上图可以看出，我们的解析实现了分流。国内线路访问Coding pages，国际线路访问Github Pages。 托管平台设置Coding平台进入对应项目的 pages 设置页面（项目 &gt; 代码 &gt; pages服务） 成功后会显示： Github平台进入对应项目的 pages 设置页面（setting &gt; github pages &gt; Custom domain) 成功后会显示： 到此我们的博客就可以正常运行了！！ 总结一切搞定后，在回头看一下我们的问题：@ 两个地址的统计信息（文章阅读量，访问量等）相互独立，不能合并； 从两个地址访问都会跳转到我们绑定的域名。统计信息自然也是绑定后域名的信息。 @ github pages国内访问速度慢（300ms左右） 我们测试一下 Ping：(表现不错) @ 托管平台给出的二级域名太丑。 不存在的…..]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
        <tag>域名</tag>
        <tag>前端杂货铺</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO 博客同时部署到 GitHub & Coding]]></title>
    <url>%2F2017%2F03%2F08%2Fgithub%26coding%2F</url>
    <content type="text"><![CDATA[很多人都把 hexo 托管到 Github 上，因为 Github 大家都用的比较久了。但是，你的博客主要访问者肯定还是国内的用户，国内的用户访问 coding 比 github 是要快不少的。还可以利用域名解析实现国内的走 coding，海外的走github，分流网站的访问。 注册GitHub和Codinggithub官网 &nbsp;&nbsp;||&nbsp;&nbsp; Coding官网 &nbsp;&nbsp;注册就不必多说，不会的可自行百度。 需要注意的是：最好使用同一个 用户名 和 邮箱 ，以免引起不必要的麻烦。 创建项目在GitHub上创建项目，名称为：yourname.github.io在Coding上创建项目，名称为：yourname 配置SSH配置 shh key 是让本地 git 项目与远程的 github 建立联系 获取ssh1、检查是否已经有SSH Key，打开 Git Bash，输入 1cd ~/.ssh 2、如果没有 .ssh 这个目录，则生成一个新的 SSH，输入 1ssh-keygen -t rsa -C &quot;your e-mail&quot; 注意: 此处的邮箱地址，是你注册 GitHub 和 coding 时的邮箱地址; 此处的「-C」的是大写的「C」 。 3、接下来几步都直接按回车键,然后系统会要你输入密码 (防止别人往你的项目里提交内容) 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 成功后，我们打开 C:\Users\cwyaml.ssh 打开 id_rsa.pub 文件。里面的代码就是 ssh key。 添加 SSH Key 到 GitHub 和 CodingGitHub添加方法： 进入Github官网，点击头像，再按 settings 进入设置。 点击 New SSH key 创建 title输入邮箱，key里面粘贴刚才右击复制的内容,再点 Add SSH key 即可。（会让你输入密码） Coding添加方法： 登录账号后点击 左侧账户 在点 SSH公钥 设置即可 。（同样要输入密码） 测试SSH是否配置成功打开 Git Bash，首先测试 GitHub 是否成功？输入:1ssh -T git@github.com (如配置了密码则要输入密码,输完按回车。)如果显示以下内容，则说明 Github 中的 ssh 配置成功。12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 然后测试 Coding 是否成功？1ssh -T git@git.coding.net 如果显示以下则说明配置成功：1Hello username You&apos;ve connected to Coding.net by SSH successfully! 上传博客文件修改站点配置文件：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:cwyaml/cwyaml.github.io.git,master coding: git@git.coding.net:cwyaml/cwyaml.git,master 然后你就可以 hexo c、hexo g、hexo d 了。 开启pages服务GitHub 已经默认开启，就不必多说了。Coding 进入对应项目，点击 代码&gt;pages服务 ，把部署来源改为 master 即可。 访问博客这样我们整个部署过程就完成了。有两个地址可以访问我们的博客：GitHub pages：https://cwyaml.github.ioCoding pages：https://cwyaml.coding.me]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 备份]]></title>
    <url>%2F2017%2F03%2F07%2Fbackup%2F</url>
    <content type="text"><![CDATA[用Hexo写博客是一件比较享受的事情，无奈如果换电脑或者系统崩了的话，你就会一脸懵B了，备份博客就显得尤为重要。先说说我的感受，博客刚搭建好的时候就想过这个问题，那时候对 git 似懂非懂吧。在网上找了很多教程方法，大概就是说要创建一个分支来存放 blog 文件，但是翻腾来翻腾去还是没有搞定。最后索性简单粗暴点，在 GitHub 上创建一个仓库，把 blog 文件整个打包上传。使用过程中发现这个方法还不错，至少对于小白来说很容易理解，也很难出错，就一直沿用到现在。 这种方式虽然能够备份 Hexo 博客的源文件，但是对于博主这种懒人，每次更新博文都需要输入两三行重复的Git命令真是一件麻烦的事情。 自动备份准备本方法需要提前将 Hexo 加入 Git仓库 并与 Github 远程仓库绑定之后，才能正常工作。具体做法可以参考：上传本地项目到GitHub 安装 shelljs 模块要实现这个自动备份功能，需要依赖 NodeJs 的一个 shelljs 模块,该模块重新包装了 child_process,调用系统命令更加的方便。使用以下命令，完成 shelljs 模块的安装：1npm install --save shelljs 编写自动备份脚本待到模块安装完成，在Hexo根目录 的 scripts文件夹下新建一个js文件，文件名随意取。如果没有scripts目录，请新建一个。123456789101112131415161718192021222324252627282930require(&apos;shelljs/global&apos;);try &#123; hexo.on(&apos;deployAfter&apos;, function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(&quot;产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：&quot; + e.toString());&#125;function run() &#123; if (!which(&apos;git&apos;)) &#123; echo(&apos;Sorry, this script requires git&apos;); exit(1); &#125; else &#123; echo(&quot;======================Auto Backup Begin===========================&quot;); cd(&apos;C:/Blog&apos;); //此处修改为Hexo根目录路径 if (exec(&apos;git add .&apos;).code !== 0) &#123; echo(&apos;Error: Git add failed&apos;); exit(1); &#125; if (exec(&apos;git commit -m &quot;Form auto backup script\&apos;s commit&quot;&apos;).code !== 0) &#123; echo(&apos;Error: Git commit failed&apos;); exit(1); &#125; if (exec(&apos;git push origin master&apos;).code !== 0) &#123; echo(&apos;Error: Git push failed&apos;); exit(1); &#125; echo(&quot;==================Auto Backup Complete============================&quot;) &#125;&#125; 注意： 其中，需要修改第17行的 D:/hexo 路径为 Hexo的根目录 路径。（脚本中的路径为博主的Hexo路径） 如果你的Git远程仓库名称不为 origin 的话，还需要修改第28行执行的push命令，修改成自己的远程仓库名和相应的分支名。 测试保存脚本并退出，然后执行 hexo d 命令，将会得到类似以下结果:12345678910111213141516171819202122232425262728293031323334353637383940INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder.........======================Auto Backup Begin===========================warning: LF will be replaced by CRLF in package.json.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/hexo1.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/update to github.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/wangyimusic.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in themes/next-5.0.1/layout/_partials/head.swig.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/backup.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/encrypt.md.The file will have its original line endings in your working directory.[master 1bb6cc5] Form auto backup script&apos;s commit Committer: unknown Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly. Run thefollowing command and follow the instructions in your editor to edityour configuration file: git config --global --editAfter doing this, you may fix the identity used for this commit with: git commit --amend --reset-author 6 files changed, 177 insertions(+), 2 deletions(-) create mode 100644 scripts/autobackup.js create mode 100644 source/_posts/backup.md create mode 100644 source/_posts/encrypt.mdTo https://github.com/cwyaml/blog-backup.git d7bc718..1bb6cc5 master -&gt; master==================Auto Backup Complete============================ 这样子，每次更新博文并 deploy 到服务器上之后，备份就自动启动并完成备份啦~是不是很方便呢？ Enjoy it！ 参考：wanghao大神 自动备份Hexo博客源文件]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
        <tag>backup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你制作音乐外链]]></title>
    <url>%2F2017%2F03%2F02%2Fmusic%2F</url>
    <content type="text"><![CDATA[本篇文章讲怎样制作音乐外链，我主要用来为自己的博客添加背景音乐。（其实主要用来装X） 通用方法首先你需要下载想要的歌曲：QQ音乐、网易云音乐需要安装客户端才能下载。虾米音乐可以在网页直接下载。总之把需要的歌曲下载下来就可以了！！ 我们利用 七牛云存储 来自动生成歌曲外链。第一步：注册、登录第二步：在对象存储中新建一个仓库，命名为 music 。第三步：在内容管理中上传歌曲文件 用这种方法所有歌曲（只要能下载）都能获得，并且永久有效 网易云音乐获取方法第一步： 先获取歌曲id，直接打开网易云音乐网页版: http://music.163.com搜索自己喜欢的音乐，并获取歌曲的 ID 。举个例子：（id很明显吧） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://music.163.com/#/song?id=443205403 第二步： 将下面网址中的两处id替换成的歌曲idhttp://music.163.com/api/song/detail/?id=425137664&amp;ids=[425137664]&amp;csrf_token=你将会获得一大串代码：外链就隐藏其中。。找不到的话就把这段代码复制到编辑器里，ctrl+F 查找 .mp31234567891011121314&#123;&quot;songs&quot;:[&#123;&quot;name&quot;:&quot;原来都是梦 &quot;,&quot;id&quot;:425137664,&quot;position&quot;:1,&quot;alias&quot;:[],&quot;status&quot;:0,&quot;fee&quot;:0,&quot;copyrightId&quot;:0,&quot;disc&quot;:&quot;&quot;,&quot;no&quot;:1,&quot;artists&quot;:[&#123;&quot;name&quot;:&quot;李行亮&quot;,&quot;id&quot;:4093,&quot;picId&quot;:0,&quot;img1v1Id&quot;:0,&quot;briefDesc&quot;:&quot;&quot;,&quot;picUrl&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;img1v1Url&quot;:&quot;http://p4.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;albumSize&quot;:0,&quot;alias&quot;:[],&quot;trans&quot;:&quot;&quot;,&quot;musicSize&quot;:0&#125;],&quot;album&quot;:&#123;&quot;name&quot;:&quot;原来都是梦&quot;,&quot;id&quot;:34816208,&quot;type&quot;:&quot;EP/Single&quot;,&quot;size&quot;:2,&quot;picId&quot;:3432675310535810,&quot;blurPicUrl&quot;:&quot;http://p3.music.126.net/LNL0l5xhstsgIILEaVkprg==/3432675310535810.jpg&quot;,&quot;companyId&quot;:0,&quot;pic&quot;:3432675310535810,&quot;picUrl&quot;:&quot;http://p3.music.126.net/LNL0l5xhstsgIILEaVkprg==/3432675310535810.jpg&quot;,&quot;publishTime&quot;:1470844800007,&quot;description&quot;:&quot;&quot;,&quot;tags&quot;:&quot;&quot;,&quot;company&quot;:&quot;百纳娱乐&quot;,&quot;briefDesc&quot;:&quot;&quot;,&quot;artist&quot;:&#123;&quot;name&quot;:&quot;&quot;,&quot;id&quot;:0,&quot;picId&quot;:0,&quot;img1v1Id&quot;:0,&quot;briefDesc&quot;:&quot;&quot;,&quot;picUrl&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;img1v1Url&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;albumSize&quot;:0,&quot;alias&quot;:[],&quot;trans&quot;:&quot;&quot;,&quot;musicSize&quot;:0&#125;,&quot;songs&quot;:[],&quot;alias&quot;:[],&quot;status&quot;:0,&quot;copyrightId&quot;:0,&quot;commentThreadId&quot;:&quot;R_AL_3_34816208&quot;,&quot;artists&quot;:[&#123;&quot;name&quot;:&quot;李行亮&quot;,&quot;id&quot;:4093,&quot;picId&quot;:0,&quot;img1v1Id&quot;:0,&quot;briefDesc&quot;:&quot;&quot;,&quot;picUrl&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;img1v1Url&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;albumSize&quot;:0,&quot;alias&quot;:[],&quot;trans&quot;:&quot;&quot;,&quot;musicSize&quot;:0&#125;],&quot;subType&quot;:&quot;录音室版&quot;&#125;,&quot;starred&quot;:false,&quot;popularity&quot;:100.0,&quot;score&quot;:100,&quot;starredNum&quot;:0,&quot;duration&quot;:262500,&quot;playedNum&quot;:0,&quot;dayPlays&quot;:0,&quot;hearTime&quot;:0,&quot;ringtone&quot;:null,&quot;crbt&quot;:null,&quot;audition&quot;:null,&quot;copyFrom&quot;:&quot;&quot;,&quot;commentThreadId&quot;:&quot;R_SO_4_425137664&quot;,&quot;rtUrl&quot;:null,&quot;ftype&quot;:0,&quot;rtUrls&quot;:[],&quot;copyright&quot;:0,&quot;rurl&quot;:null,&quot;mvid&quot;:0,&quot;rtype&quot;:0,&quot;bMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538623,&quot;size&quot;:3150725,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605233,&quot;bitrate&quot;:96000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.21&#125;,&quot;mp3Url&quot;:&quot;http://m2.music.126.net/eU871p87-mpm5JcrqnsP2w==/1413971967605233.mp3&quot;,&quot;hMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538621,&quot;size&quot;:10502313,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605231,&quot;bitrate&quot;:320000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.63&#125;,&quot;mMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538622,&quot;size&quot;:5251179,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605232,&quot;bitrate&quot;:160000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.19&#125;,&quot;lMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538623,&quot;size&quot;:3150725,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605233,&quot;bitrate&quot;:96000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.21&#125;&#125;],&quot;equalizers&quot;:&#123;&#125;,&quot;code&quot;:200&#125; 第三步： 将上一步中获取到的网址放到地址栏中，若能正常播放音乐说明获取到的网址是正确的。然后你就可以把这些歌曲添加到自己的网页中了！！ 用这种方法有些歌曲并不能获得，不过时效很长（只要网易云能听）]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最简单的翻墙方法]]></title>
    <url>%2F2017%2F03%2F01%2Fhost%2F</url>
    <content type="text"><![CDATA[分享一个可用的翻墙方法，解决 Google、Facebook、及 Twitter 等被墙问题。 ※※※ 本页面长期更新可用 hosts 文件。 ※※※ 废话不多说,直接讲方法只需要替换系统的 hosts 文件，就可以使用google、facebook… hosts 所在文件夹： Windows 系统hosts位于 C:\Windows\System32\drivers\etc\hosts Android（安卓）系统hosts位于 /etc/hosts Mac（苹果电脑）系统hosts位于 /etc/hosts iPhone（iOS）系统hosts位于 /etc/hosts Linux 系统hosts位于 /etc/hosts 绝大多数Unix系统都是在 /etc/hosts 可用hosts文件 提取码：b69i 解压密码：laod 注意：Google、Gmail、维基百科、Twitter、Facebook 等必须请用 https 加密方式打开。一般这些网站都是SSL加密链接，如：谷歌学术：https://scholar.google.com/谷歌：https://www.google.com/ncr谷歌香港：https://www.google.com.hk/ncrTwitter：https://twitter.com/?lang=zh-cn]]></content>
      <categories>
        <category>电脑小技巧</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
        <tag>hosts</tag>
        <tag>Google</tag>
        <tag>YouTuBe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - Ajax 总结]]></title>
    <url>%2F2017%2F02%2F23%2FAjax%2F</url>
    <content type="text"><![CDATA[2005年 Jesse James Garrett 发表了一篇文章，介绍了 Ajax 这门技术。这种技术能够向服务器请求额外的数据而无需刷新页面，带来了很好的用户体验，一时间席卷全球。 XMLHttpRequestAjax 技术的核心是 XMLHttpRequest 对象（简称XHR）。这是微软首先引入的一个特性，其他浏览器后来也都有相同的实现。XHR 为向服务器请求和解析服务器响应提供了流畅的接口。用异步的方式从服务器获取更多信息。这意味着，只要用户触发了某一事件，再不刷新网页的情况下，更新服务器最新数据。 虽然 Ajax 中的 X 代表 XML ，但 Ajax 通信和数据格式无关，也就是说这种技术不一定使用 XML。 XHR使用方法XHR 对象的使用方法总体上分为三步：第一步： 创建 XMLHttpRequest 对象。W3C 支持原生的 XMLHttpRequest 对象，IE6使用的是 MSXML 库中的 ActiveXObject 对象，所以要做兼容！123456789101112131415161718192021function createXHR()&#123; if(typeof XMLHttpRequest != 'undefined')&#123; return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject != 'undefined')&#123; var version = [ 'MSXML2.XMLhttp.6.0', 'MSXML2.XMLhttp.3.0', 'MSXML2.XMLhttp' ]; for(var i = 0;i &lt; version.length;i++)&#123; try&#123; return new ActiveXObject(); &#125;catch(e)&#123; //跳过 &#125; &#125; &#125;else&#123; throw new Error('不支持Ajax！！'); &#125;&#125;var xhr = createXHR(); //创建对象 第二步： 准备发送请求用 open() 方法，接受三个参数：发送方式（get/post）、请求的 url、同步或者异步（同步为false、异步为true）1xhr.open('get','demo.php','false'); php 文件内容为：123&lt;?php echo Date('Y-m-d H:i:s'); //当前时间?&gt; 第三步： 发送请求 send() 方法 ，接受一个参数作为请求主体发送的数据（非 post 方式一般填 null 即可）1xhr.send(null); 同步方式当请求发送到服务器端，收到响应后，相应的数据会自动填充 XHR 对象的属性。一共有四个属性： 属性 返回值 responseText 作为响应主体被返回 responseXML 如果响应主体内容类型是 text/xml 或 application/xml，返回包含响应数据的 XMLDOM 文档 status 响应的 HTTP 状态 statusText HTTP 状态的说明 接受响应之后，第一步检查 status 属性，以确定响应已经成功返回。一般把 HTTP 状态代码为 200 作为成功的标志。（304 代表本地缓存中存在请求的页面缓存，也是响应成功的标志）12345678910document.onclick = function()&#123; var xhr = createXHR(); xhr.open('get','demo.php',false); xhr.send(null); if(xhr.status == 200)&#123; alert(xhr.responseText); &#125;else&#123; alert('请求失败'); &#125;&#125; 注意: 同步方式 send() 后才能收到返回数据 异步方式：使用异步调用才是我们真正常用的手段。使用异步调用的时候 ，需要触发 readystatechange 事件，然后检测 readyState 属性值。值为 4 时表示 接受到全部响应数据，并且可以使用。1234567891011121314document.onclick = function()&#123; var xhr = createXHR(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; //完全响应 if(xhr.status == 200)&#123; alert(xhr.responseText); &#125;else&#123; alert('请求失败！'); &#125; &#125; &#125; xhr.open('get','demo.php',true); xhr.send(null);&#125; PS: readystatechange 事件要放在发送请求之前！！！ GET方式GET方式主要用于向服务器请求获取数据，反应在 URL 中：123456789101112131415161718192021222324document.onclick = function()&#123; var xhr = createXHR(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200 || xhr.status == 304)&#123; alert(xhr.responseText); &#125;else&#123; alert('Ajax错误！'); &#125; &#125; &#125;; var url = 'demo.php'; url = addURLParam(url,'name','cwyaml'); url = addURLParam(url,'age',100); xhr.open('get',url,true); xhr.send(null);&#125;//编码函数function addURLParam(url,name,value)&#123; url += url.indexOf('?') == -1 ? '?' : '&amp;'; url += encodeURIComponent(name) + '=' + encodeURIComponent(value); return url;&#125; POST方式在 send() 执行之前需要修改头部信息1234567891011121314151617181920document.onclick = function()&#123; var xhr = createXHR(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200 || xhr.status == 304)&#123; alert(xhr.responseText); &#125;else&#123; alert('Ajax错误！'); &#125; &#125; &#125;; var url = strParam('name','cwyaml'); url += strParam('age',23); xhr.open('get','demo.php',true); xhr.send(url);&#125;//字符编码function strParam(name,value)&#123; return encodeURIComponent(name) + '=' + encodeURIComponent(value) + '&amp;';&#125; 浏览器兼容这里的实现方式和 JQuery 实现 Ajax 的方式相同123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//创建对象function createXHR()&#123; if(typeof XMLHttpRequest != 'undefined')&#123; //W3C return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject != 'undefined')&#123; //IE var version = [ 'MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp' ]; for(var i = 0;i &lt; version.length;i++)&#123; try&#123; return new ActiveXObject(version[i]); &#125;catch(e)&#123; //跳过！ &#125; &#125; &#125;else&#123; throw new Error('不支持Ajax!'); &#125;&#125;//Ajax请求function ajax(obj)&#123; var xhr = createXHR(); obj.date = strParam(obj.date); //字符编码是为了解决IE缓存问题 //判断异步 if(obj.async === true)&#123; xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; callback(); &#125; &#125; &#125; //判断get if(obj.method === 'get')&#123; obj.url = obj.url + '?rand=' + Math.random() + '&amp;' + obj.date; xhr.open(obj.method,obj.url,obj.async); xhr.send(null); &#125; //判断post if(obj.method === 'post')&#123; xhr.open(obj.method,obj.url,obj.async); xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); xhr.send(obj.date); &#125; //判断同步 同步要放在 send 后面！！！一定要注意 if(obj.async === false)&#123; callback(); &#125; function callback()&#123; if(xhr.status == 200)&#123; obj.success(xhr.responseText); &#125;else&#123; alert('Ajax错误！'); &#125; &#125;&#125;//字符编码function strParam(date)&#123; var arr = []; for(var i in date)&#123; arr.push(encodeURIComponent(i) + '=' + encodeURIComponent(date[i])); &#125; return arr.join('&amp;');&#125;//调用方法document.onclick = function()&#123; ajax(&#123; method : 'get', url : 'demo.php', date:&#123; 'name' : 'cwyaml', 'age' : 123 &#125;, success : function(text)&#123; alert(text); &#125;, async : true &#125;);&#125; 总结在写浏览器兼容的时候出现了一个问题：同步请求时 xhr.status 始终返回 0 。这令我百思不得其解，检查代码好几遍没发现错误，上百度找解决办法也没有结果，折腾了一上午时间才发现原来 把同步请求写在了 send() 前面 。我也是醉了，同步是单线程的，不发送请求怎么能得到返回数据。不过这也是学习中的一点乐趣，解决问题后的心情还是很爽的。以后一定要细心再细心，不要再这些小问题上浪费太多时间。]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 使用中常见的问题及解决方法]]></title>
    <url>%2F2017%2F02%2F14%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[就像 Markdown 官方文档里描述的一样：可读性，无论如何，都是最重要的。 Markdown 的目标是实现 &nbsp; 『易读易写』 。&nbsp;Markdown 从发布到现在备受好评，经过这一段的使用，整体感觉挺顺手，不过还是存在很多问题，所以总结一下喽。。 编辑器其实自己喜欢的才是最好的。(像 vim 、emacs什么的不推荐，因为我也不会用) MAC平台自己没用过，不做推荐。你可以看看这个帖子：Mac 上适合码农用的 Markdown 编辑器是什么？ Windows平台印象笔记马克飞象传送门，界面不是很好看，书写的时候感觉很别扭 有道云笔记有道传送门，同样很丑，强迫症受不了 Sublime Text强大的 Sublime Text 总是能给我们很多惊喜，经过各种对比，sublime 满足了我对审美的要求。首先我们需要安装两个插件：（至于怎么安装就不说了） markdownEditing 用来书写 markdownPreview 用来预览 Atom（强烈推荐）GitHub 推出的编辑器，界面很好（就是启动有点慢），必须支持一下。默认继承了 markdown 预览，快捷键为 Ctrl+shift+M。推荐插件： markdown-preview 实时预览 markdown-scroll-sync 编辑区和预览区同步滚动 markdown-writer 方便管理图片链接等 markdown-table-formatte 表格格式化 使用方法Markdown官方文档 常见问题汇总html标签显示比如说我要写一篇博客，标题为“html中 &lt;canvas&gt; 的使用”1## html中 &lt;canvas&gt; 的使用 如果这样写就会出现排版上的问题（不信你试一下），那么怎么解决呢？其实认真想一下就能明白，Markdown 的语法是基于 html 的，我们直接写 &lt;canvas&gt;，自然会被理解为一个标签，而不是要显示的文本。。所以，问题回归到 html 上。在网页中，我们要显示 &lt;canvas&gt; 时要用到 转义字符, 所以 Markdown 中也一样，我们应该这样写：1## html中 &amp;lt;canvas&amp;gt; 的使用 代码语法高亮这个问题困扰了我好久，官方文档里竟然没有说明！只好自己去查找方法。Markdown 中显示代码块是这样的格式：显示为：1&lt;p&gt;这是一个p标签&lt;/p&gt; 而我们这样写：就可以实现代码高亮了1&lt;p&gt;这是一个p标签&lt;/p&gt; 据说这种方式一共支持四十多种语言，有兴趣的话你可以研究一下。 图片Markdown 中嵌入图片，如果使用本地图片就要用到 html 标签来引用，这种方法很稳定，但是使文档变得很大（一张图片最少几百k吧）。所以我们要用到 图床 。 贴图库推荐使用 &nbsp; 贴图库 &nbsp;快速，免费（我使用过程中没掉过链子） 注册登录，就可以上传图片，每张图片自动生成 原图、展示图和 缩略图的图片外链、html代码、Markdown外链等。只要把对应的代码粘贴到你的文档中就可以了。。 七牛云存储这个最近很火，可靠、可扩展、低成本等等有很多优点。你可以试一下。我们主要用到他的 对象存储 服务，创建一个公开仓库，把图片上传就可以生成外链了。 gifGithub 上的开源项目，ReadMe.md 是也支持 Markdown 语法的，通常会看到很多开源项目的 ReadMe 中有 动态演示效果，看到这个项目的人一目了然，非常方便，gif本身也是一种图片格式，在 Markdown 中 引用时和正常图片的引用一样，但需要专门的工具生成 gif 格式的图片才行，在这里强烈推荐 LICEcap，它是一款 windows 上的录屏软件，录制后保存的格式为 gif，体积小并且同样也可以在图床上生成链接。 插入音乐你可以把音乐文件下载到本地，然后简单粗暴的使用 html 中的 &lt;video&gt; 标签。当然，如果这样就不必写下去了，告诉你简单的方法：网易云音乐 打开网易云音乐网页版，搜索自己喜欢的音乐，比如我找到 告白气球 我们可以看到在图片的下边有一个 生成外链播放器 , 点击会出现 选择 合适的尺寸 和 播放模式 之后。把下边的代码复制到你的 Markdown 文档中就可以了。试着听一下吧！！(我选择了最小尺寸) 试着去把一个 歌单生成外链播放器 插入到你的 Markdown 中，这样你跟新歌单你的博文也会跟着变化，而不必在想跟换歌曲时头疼]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub搭建博客 - 优化]]></title>
    <url>%2F2017%2F01%2F25%2Fhexo2%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍基于NexT主题的一些第三方功能的实现。基本功能的设置可以参考 Next官网文档 首先，我们需要明白： 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。我们约定，将前者称为 站点配置文件 ，后者称为 主题配置文件 。 背景动态背景（最新版本中以内置）修改 _layout.swig 模板模板位置：themes\next\layout\_layout.swig在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）12345&lt;!-- 动态背景 --&gt;#默认灰色线条&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt;#浅蓝色线条&lt;script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"&gt;&lt;/script&gt; 然后在 themes\source\js\src\ 下新建文件 particle.js 写上以下代码:1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 鼠标点击小红心在 \themes\next\source\js\src 文件目录下添加 love.js 文件。内容为：1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码：12&lt;!-- 小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 头像圆形旋转修改文件 themes/next/source/css/_common/components/sidebar/sidebar-author.styl我的样式文件 文章结尾模板在 \themes\next\_macro 文件目录下添加 passage-end-tag.swig 文件，内容为：(当然你也可以修改为自己喜欢的样式)1234567891011121314&#123;% if theme.passage_end_tag.enabled %&#125;&lt;blockquote class="blockquote-center"&gt; &lt;p&gt;如果您觉得本博客还不错，欢迎继续关注本博客，欢迎多提宝贵意见，非常感谢！&lt;/p&gt;&lt;/blockquote&gt;&lt;span id="inline-green" style="border-radius:3px;"&gt;作者&lt;/span&gt;：&lt;a class="link-blue" href="https://github.com/cwyaml" target="_blank"&gt;cwyaml&lt;/a&gt;有问题请 &lt;a class="link-blue" href="https://cwyaml.github.io/about/"&gt;留言&lt;/a&gt; 或者私信我的 &lt;a class="link-blue" href="http://weibo.com/u/5742789641?refer_flag=1001030102_&amp;is_all=1" target="_blank"&gt;微博&lt;/a&gt;。&lt;div style="text-align:center; color:#ccc; font-size:14px; "&gt; ------本文结束 &amp;nbsp;&lt;i class="fa fa-paw"&gt;&lt;/i&gt;&amp;nbsp; 感谢阅读------&lt;/div&gt;&#123;% endif %&#125; 找到 \themes\next\_macro\post.swig 文件，使用查找功能找到 reward.swig，在这一个 &lt;div&gt; 的前面添加：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 文章底部标签云锚点在 themes\next\layout\_macro\post.swig 文件中找到以下代码：12345678910&lt;footer class="post-footer"&gt;&lt;!--这是文章底部标签云锚点，不喜欢就注释掉 &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125; &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125;--&gt; 关于文章内文本样式Markdown 毕竟是为了方便写作，在样式上就过于单调。我们自己来给文章加一些样式。。 Next 作者提供了一个供用户自己定义样式的文件：\themes\next\source\css\_custom\custom.stl 自己按需要写在上述文件中写上自己的 class 类，然后在 Markdown 文档中使用。我的custom.styl 引用前端框架目前流行的前端框架，像 bootstrap、React、Angular 等，提供给我们很好的前端方案，我们可以把喜欢的引入到上面说的那个文件里，然后就可以使用了。 设置动态title1、在 \themes\next\source\js\src 目录下新建 dytitle.js 。添加以下内容：1234567891011121314151617&lt;!--崩溃欺骗--&gt;var OriginTitile = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/TEP.ico&quot;); document.title = &apos; 页面崩溃啦 ~ | cwyaml！&apos;; clearTimeout(titleTime); &#125; else &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/favicon.ico&quot;); document.title = &apos; 噫又好了~ &apos; + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125; &#125;); 2、更改 \themes\next\layout\_layout.swig 。在 &lt;/body&gt; 之前添加：12&lt;!--崩溃欺骗--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/dytitle.js&quot;&gt;&lt;/script&gt; 首页动画在 主题配置文件 中，找到 Motion 字段。true 和 false 控制动画的开启与关闭。12# Motionuse_motion: true 内容宽度现在一般的笔记本都在15寸以上，博客页面两侧留白太多就显得没有必要，并且不美观，所以有必要调整一下宽度。（可以慢慢试着调整到最合适的状态）1、找到 \themes\next\source\css\_common\components\post\post-expand.styl，找到：123@media (max-width: 767px)改为：@media (max-width: 1060px) 2、找到：\themes\next\source\css\ _variables\base.styl ，找到：123456789$main-desktop = 960px$main-desktop-large = 1200px$content-desktop = 700px改为：$main-desktop = 1060px$main-desktop-large = 1200px$content-desktop = 800px 3、找到 \themes\next\source\css\_schemes\Pisces\_layout.styl ，将第 4 行的 width 改为 1060px ，修改后如下：1234.header &#123; position: relative; margin: 0 auto; width: 1060px; 统计功能文章阅读次数统计参考： LeanCloud 不蒜子统计站点访问1、全局配置：编辑 主题配置文件 中的 busuanzi_count 的配置项，配置以下内容：当 enable: true 时，代表开启全局开关。若 site_uv、site_pv、page_pv 的值均为 false 时，不蒜子仅作记录而不会在页面上显示。2、站点 UV/PV 配置：当 site_uv: true 时，代表在页面底部显示站点的 UV 值。当 site_pv: true 时，代表在页面底部显示站点的 PV 值site_uv_header(site_pv_header) 和 site_uv_footer(site_pv_footer) 为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为 [site_uv_header]UV值/PV值[site_uv_footer]。1234567891011busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站总访问量 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: 您是第 site_pv_footer: 位小伙伴 3、单页面 PV 值设置：1234# custom pv span for one page onlypage_pv: falsepage_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;page_pv_footer: 开启打赏功能越来越多的平台（微信公众平台，新浪微博，简书等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址（放在博客根目录的source文件夹下即可） 即可开启该功能。123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /weixin.pngalipay: /zhifubao.png 设置RSS1、需要安装 hexo-generator-feed 插件。1$ npm install hexo-generator-feed --save 2、在 站点配置文件 中添加字段：123456feed: type: atom path: atom.xml limit: 20 hub: content: 听音乐1、下载js文件：high.swig。放在 \themes\next\layout\_macro 目录下。2、在侧边栏引用该文件：修改 \themes\next\layout\_macro\sidebar.swig ，添加以下代码： 1&#123;% include &apos;high.swig&apos; %&#125; 3、样式修改：使 听音乐 和 RSS 并排展示，修改 \themes\next\source\css\_schemes\Pisces\_sidebar.styl 1display: inline-block; 4、添加自己喜欢的音乐：修改其中的歌曲链接即可（获取歌曲外链教程） 123456var songs = [ "http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3", "http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3", "http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3", "......" ]; 5、首页听音乐摇晃：需要加载css样式。在 themes\next\layout\_layout.swig 文件的 body标签结束前 添加以下代码： 12&lt;!-- 听音乐摇晃 --&gt;&lt;link href="http://s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css" rel="stylesheet" type="text/css"&gt; 注意： 有时候使用 Firefox 、Chrome时会提示非法插件并禁止使用，遇到这种情况我们把样式代码引入到 \themes\next\source\css\_custom\custom.stl 文件即可解决。 添加 Forkme on GitHub 丝带首先进入 GitHub Ribbons 选择自己喜欢的丝带样式。找到 \themes\next\layout\_layout.swig 文件，在 &lt;header&gt; 标签前面添加：（记得把链接修改成自己的GitHub主页）1&lt;a href="https://github.com/you"&gt;&lt;img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png"&gt;&lt;/a&gt; 给 Blog 添加 LICENSE修改 主题配置文件 （使用查找功能）12345# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: Local Search1、安装 hexo-generator-searchdb1$ npm install hexo-generator-searchdb --save 2、编辑 站点配置文件 ，添加以下字段：12345search: path: search.xml field: post format: html limit: 10000 3、编辑 主题配置文件 ，启用本地搜索123# Local searchlocal_search: enable: true 多说（官方以停用）多说评论使用多说前需要先在 多说 创建一个站点。具体步骤如下：1、登录后在首页选择“我要安装”。2、创建站点，填写站点相关信息。多说域名 这一栏填写的就是你的 duoshuo_shortname, 3、创建站点完成后在 站点配置文件 中新增 duoshuo_shortname 字段，值设置成上一步中的值即可。 多说评论框自定义 : 我的样式代码 多说分享在 主题配置文件 中设置：12# Shareduoshuo_share: true 禁用鼠标经过时分享更多功能（有bug）:找到 \themes\next\layout\_partials\share\duoshuo_share.swig 文件，替换内容为：123456789101112131415161718&lt;div class="ds-share flat" data-thread-key="&#123;&#123; page.path &#125;&#125;" data-title="&#123;&#123; page.title &#125;&#125;" data-content="" data-url="&#123;&#123; page.permalink &#125;&#125;"&gt; &lt;div class="ds-share-inline"&gt; &lt;ul class="ds-share-icons-16"&gt; &lt;li&gt;&lt;span class="ds-more"&gt;分享到：&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-weibo" href="javascript:void(0);" data-service="weibo"&gt;微博&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-qzone" href="javascript:void(0);" data-service="qzone"&gt;QQ空间&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-qqt" href="javascript:void(0);" data-service="qqt"&gt;腾讯微博&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-wechat" href="javascript:void(0);" data-service="wechat"&gt;微信&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-facebook" href="javascript:void(0);" data-service="facebook"&gt;Facebook&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-google" href="javascript:void(0);" data-service="google"&gt;Google&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="ds-share-icons-more"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 博文压缩目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp插件。hexo-all-minifier 虽然使用比较简单，而且也可以压缩图片，但是对文章缩进（输入法全拼模式下按 Tab）不支持，所以暂时使用 gulp 压缩手段。 hexo-all-minifier 使用方法安装 hexo-all-minifier，在站点的根目录下执行以下命令：1$ npm install hexo-all-minifier --save hexo g 编译的时候就会自动压缩 HTML、JS、图片。详情参考插件介绍 hexo-all-minifier glup 使用方法hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在 package.json 同级目录下，新建 gulpfile.js 并填入以下内容：123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;amp;&amp;amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 博文置顶1、修改 hexo-generator-index 插件。 替换文件：node_modules/hexo-generator-index/lib/generator.js 为：generator.js2、设置文章置顶 在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如： 1234567---title: cwyaml 图集categories: [图片]tags: [picture]date: 2015-04-02 14:36:04top: 10--- 博文部署 message在 \node_modules\hexo-deployer-git\lib\deployer.js 文件末尾找到这一句：（记得个性一点）1Lucky Boy: &#123;&#123; now(\&apos;YYYY-MM-DD HH:mm:ss\&apos;) &#125;&#125;. 图片模式 新建博文，设置 type: &quot;picture&quot;，使用 {\% gp x-x \%} ... {\% endgp \%} 标签引用要展示的图片地址，如下所示：(其中的 x-x 为图片展示效果，可以自己尝试一下) 123456789101112131415---title: Naruto-Picturescategories: [图片]tags: [picture]date: 2014-06-02 10:36:02type: "picture"comments: false---&#123;% gp 5-3 %&#125;![](http://oapjp6spr.bkt.clouddn.com/18210.jpg)![](http://oapjp6spr.bkt.clouddn.com/196232.jpg)![](http://oapjp6spr.bkt.clouddn.com/224147.jpg)![](http://oapjp6spr.bkt.clouddn.com/199301.jpg)![](http://oapjp6spr.bkt.clouddn.com/213318.jpg)&#123;% endgp %&#125;]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub出品 文本编辑器 Atom]]></title>
    <url>%2F2017%2F01%2F19%2Fatom%2F</url>
    <content type="text"><![CDATA[在代码编辑器、文本编辑器领域，有着不少的「神器」级的产品，如历史悠久的 VIM、Emacs 以及如今当红的 SublimeText。另外还有 VS Code、EditPlus、NotePad++、UltraEdit 等一大堆流行的利器，可谓百家争鸣。 简介作为目前全球范围内影响力最大的代码仓库/开源社区，GitHub 的程序员们并不满足于此。他们使用目前最先进流行的技术重新打造了一款称为“属于21世纪”的代码编辑器——Atom， 它开源免费跨平台，并且整合 GIT 并提供类似 SublimeText 的包管理功能，支持插件扩展，可配置性非常高…… 优点1、开源，完全 免费；2、它提供了与 SublimeText 上类似的 Package Control (包管理)功能，人们可以非常方便地安装和管理各种插件，并将 Atom 打造成真正适合自己的开发工具；3、Atom 编辑器可以和 GIT 完美结合，所有对代码、文本的修改都能体现在编辑器的界面上。比如在文件内新写的代码会在左边标记为绿色，删除的标记为红色，修改的标记为黄色。在左边的目录导航也能方便的看到文件改动：有改动的文件其文件名和所在文件夹名都会被标记为高亮显示。编辑器底部会显示当前所在分支和对文件的修改行数统计，对于 GIT 用户来说非常方便。4、对前端友好。基于 WEB 技术（Chromium+Node.js）开发的，这足以让无数 WEB 工程师为之兴奋！用户可以用 Javascript 来编写编辑器插件，用 CSS 把主题界面改成任何你喜欢的样式等，这使得编写插件、主题、二次开发的门槛的降低了许多。这也能解释从 Atom 发布到现在不长的时间里，Atom 的 Package 和主题数量都快速增长上来了。 缺点1、启动速度慢，打开大文件慢，貌似就这一个缺点！！ 常用插件Package推荐atom-simplified-chinese-menu 汉化（如果你需要的话）Emmet 前端神器javascript-snippets js中的 emmetminimap 小地图（跟 sublime 上的一样）docblockr 养成良好的注释习惯atom-beautiful 代码格式化。支持HTML, CSS, JavaScript, PHP, Python, Ruby, Java, C, C++, C#, Objective-C…..pigments 显示颜色（rgb等都会显示）tree-view-background 左侧文件列表背景图片（个人感觉很简介、方便）Sublime-Style-Column-Selection 列编辑（也是sublime中的功能）markdown-scroll-sync 编辑markdown时预览页面随光标移动markdown-writer markdown方便管理图片链接等markdown-table-formatte markdown表格格式化highlight-selected 选中时相同文本高亮vimMode 如果你会使用 vim 的话（如果你不会的话最好别装，因为会有好多快捷键冲突）autocomplete-plus 当输入时提供可能的候选项autocomplete-paths 路径自动补全activate-power-mode 动感打字特效（这个很火但是我不喜欢） Thems推荐atom-material-ui 非常漂亮的一个主题monokai 代码高亮 常见问题汇总关于安装插件不知道是什么原因，在编辑器里面搜索插件，一直安装不成功，翻墙也不行。所以只能本地安装。1、先把插件代码库 clone 到 atom 的 插件源码目录 （如果你不知道这个文件夹在哪的话，在设置中可以直接打开）。2、在 插件文件夹中 执行 npm install (注意不要用 apm install) 可能会报错，说你的 npm 版本低什么的，不要管，大概几分钟时间，一直等下去就会安装成功。 怎么修改UI1、打开 文件 &gt; 用户样式设置 就会显示编辑器主题 style 文件，我们可以用 css 语言来自定义样式。2、Ctrl+shift+I 快捷键打开开发者工具（跟 chrome 上的一样），你就会发现定义主题是如此的简单。 ###代码括号配对高亮atom 默认的括号匹配太不明显了，跟没有差不多。修改方法：在用户样式设置文件中添加12345//匹配括号atom-text-editor.editor .bracket-matcher .region &#123; border-top:yellow; border-bottom:yellow;&#125; 隐藏缩进指示线（中间的白线）解决方案：编辑 &gt; 用户样式设置，添加以下代码：123atom-text-editor::shadow .wrap-guide &#123; visibility: hidden;&#125; 设置菜单的字体太小解决方案：编辑 &gt; 用户样式设置，添加以下代码：123.settings-view &#123; font-size: 16px;&#125; 文件标题的字体太小解决方案：编辑 &gt; 用户样式设置，添加以下代码：123.tab-bar .tab .title &#123; font-size: 13px;&#125;]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - XPath 总结]]></title>
    <url>%2F2017%2F01%2F12%2FxPath%2F</url>
    <content type="text"><![CDATA[XPath 是一种节点查找手段。它比使用 标准DOM 去查找 XML 节点更加方便、更加简单。但是 XPath 是 DOM3 中才支持的标准，并且 IE 有自己的实现方式。（IE总是自己造马车） IE中的XPathIE 提供了两种方法：1、selectSingleNode() 获取单一节点123456var xmlStr = '&lt;root&gt;&lt;user id="1"&gt;Tom&lt;/user&gt;&lt;user id="2"&gt;Lucy&lt;/user&gt;&lt;/root&gt;';var xmlDom = parseXML(xmlStr); //创建xmlDom对象var node = xmlDom.selectSingleNode('root/user'); //种方式称为节点树查找，必须从最外层开始，由外向内//只会获得第一个 useralert(node.tagName); //user 2、selectNodes() 获取节点集合12345var nodes = xmlDom.selectNodes('root/user'); //返回的是一个数组alert(nodes.length); //2//一般这样用var nodes = xmlDom.selectNodes('root[1]/user'); //获取第二个root下的所有user W3C中的XPath在 DOM3 中 XPath 规范中，最重要的两个类型是 XPathEvaluator 和 XPathResult 。其中 XPathEvaluator 用于在特定上下文对 XPath 表达式求值。 XPathEvaluator 方法一共需要传递五个参数：1.XPath路径； 2.上下文节点； 3.命名空间求解器（null）； 4.返回结果类型； 5.保存结果的 XPath 对象（null）；获取成功就返回对应的类型值，获取失败返回 null。 返回的结果类型一共有十种，常用的就两种： 常量 值 XPathResult_FIRST_ORDERED_NODE_TYPE 返回单一节点 XPathResult_ORDERED_NODE_ITERATOR_TYPE 返回节点集合 获取单一节点1234var result = xmlDom.evaluate('root/user',xmlDom,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null);if(result !== null)&#123; alert(result.singleNodeValue.textContent); //Tom &#125; 获取节点集合获取的时候只需要把返回值的类型修改为 获取节点集合 即可。得到的节点集合需要用 iterateNext() 方法使用迭代方法存入一个数组。这样就可以对数据进行操作了。12345678910var result = xmlDom.evaluate('root/user',xmlDom,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE,null);if(result !== null)&#123; var nodes = []; var node = result.iterateNext(); while(node !== null)&#123; nodes.push(node); node = result.iterateNext(); &#125;console.log(nodes[1].innerHTML); //Lucy&#125; XPath 常用语法XML加载之后就可以使用标准DOM来进行各种操作，比如上面的返回 tagName 。当然 XPath 也提供了一套方法：（这里只列举最常用的）1、相同标签问题12var node = xmlDom.selectSingleNode('root/user[1]'); alert(serializeXML(node)); //&lt;user id="2"&gt;Lucy&lt;/user&gt; 第二个user IE中下标从 0 开始！！ W3C中下标从 1 开始！！ 2、获取元素内文本12var node = xmlDom.selectSingleNode('root/user/text()');alert(serializeXML(node)); //Tom 3、跨结构查找(不关心结构层次)123var node = xmlDom.selectSingleNode('//user'); //查找整个文档中第一个uservar node = xmlDom.selectSingleNode('b//user'); //也可以限制在一个标签内查找alert(serializeXML(node)); 4、通过属性查找12var node = xmlDom.selectSingleNode('root/user[@id=2]');alert(serializeXML(node)); //&lt;user id="2"&gt;Tom&lt;/user&gt; 跨浏览器兼容鉴于IE中的相对功能较少，首先考虑 W3C。 获取单一节点1234567891011121314151617181920212223//获取单一节点 function selectSingleNode(xmlDom,xpath)&#123; var node = null; if(typeof xmlDom.evaluate != 'undefined')&#123; //W3C //让下标从 0 开始 var patten = /\[(\d+)\]/; var flag = xpath.match(patten); var num = 0; if(flag != null)&#123; num = parseInt(RegExp.$1) + 1; xpath = xpath.replace(patten,'[' + num + ']'); &#125; var result = xmlDom.evaluate(xpath,xmlDom,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null); if(result !== null)&#123; node = result.singleNodeValue; &#125; &#125;else if(typeof xmlDom.selectSingleNode != 'undefined')&#123; //IE node = xmlDom.selectSingleNode(xpath); &#125; return node;&#125; 获取节点集合1234567891011121314151617181920212223242526//获取节点集合function selectNodes(xmlDom,xpath)&#123; var nodes = []; if(typeof xmlDom.evaluate != 'undefined')&#123; //W3C //让下标从 0 开始 var patten = /\[(\d+)\]/; var flag = xpath.match(patten); var num = 0; if(flag != null)&#123; num = parseInt(RegExp.$1) + 1; xpath = xpath.replace(patten,'[' + num + ']'); &#125; var result = xmlDom.evaluate(xpath,xmlDom,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE,null); if(result !== null)&#123; var node = null; while((node = result.iterateNext())!= null)&#123; nodes.push(node); &#125; &#125; &#125;else if(typeof xmlDom.selectNodes != 'undefined')&#123; //IE nodes = xmlDom.selectNodes(xpath); &#125; return nodes;&#125;]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>XPath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Naruto-Pictures]]></title>
    <url>%2F2016%2F12%2F28%2Ftop-pitcure%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>图片</category>
      </categories>
      <tags>
        <tag>picture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 配置]]></title>
    <url>%2F2016%2F12%2F24%2Fhexo1%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍怎样利用 Hexo + Next 在 GitHub 上搭建个人博客。 简介Hexo 是一个快速、简洁且高效的静态站点生成框架，基于 Node.js 。 它有以下特点： 1、 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。2、 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。3、 一件部署只需一条指令即可部署到Github Pages，或其他网站4、 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的 主题。NexT 因其 &nbsp; 精于心，简于形 &nbsp; 的风格，一直被广大用户所喜爱。 准备工作安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 如果您的电脑中已经安装上述必备程序，跳过这一步。如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载安装 git 。 Download Now Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 Linux（Ubuntu，Debian）：sudo apt-get install git-core Linux（Fedora，Red Hat，CentOS）：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager）windows 下使用 nvm 请看这里： nvm-windows ，首先需要下载安装 nvm 。 Download Now windows下安装完nvm以后，我们可以打开命令行中执行命令12$ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。（执行完以后，我们同样可以执行命令 hexo -v 查看是否安装成功就安装成功了。）1$ npm install -g hexo-cli Hexo安装完成后，我们需要为我们的blog项目创建一个 指定文件夹 （例如我在 D 盘根目录下创建了一个文件夹 blog 。D:\blog ），在 该文件夹中 执行以下命令， Hexo 将会在指定文件夹中新建所需要的文件。12$ hexo init$ npm install 等待安装，安装完成后，指定文件夹 的目录如下：1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 继续执行命令12$ hexo g //编译$ hexo s --debug //开启本地服务 这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型： 到目前为止我们的本地博客已经部署完成。下面我们换上Next主题。 使用Next下载 NexT 主题依旧是在当前目录下，使用 Git checkout 代码：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成。 启用 NexT 主题打开 站点配置文件 (Hexo文件夹下的_config.yml文件)，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们依次执行以下命令验证主题是否正确启用。 123$ hexo clean$ hexo g$ hexo s 我们在浏览器中访问 http://localhost:4000/ ，你将看到： 总结本地调试三部曲：123$ hexo clean$ hexo g$ hexo s --debug 这种带debug的运行，如果出现错误，可以在命令行中看到错误提示信息。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 面向对象总结]]></title>
    <url>%2F2016%2F12%2F05%2FObject%2F</url>
    <content type="text"><![CDATA[面向对象的语言有一个标志，那就是“类”的概念，所谓的“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript语言的对象体系，不是基于“类”的，而是基于 构造函数（constructor）和 原型链（prototype）。 对象的概念我们从两个层次来理解：1、“对象”是单个实物的抽象一本书、一辆汽车、一个人都可以是“对象”，一个数据库、一张网页、一个与远程服务器的连接也可以是“对象”。当实物被抽象成“对象”，实物之间的关系就变成了“对象”之间的 关系，从而就可以模拟现实情况，针对“对象”进行编程。2、“对象”是一个容器，封装了“属性”（property）和“方法”（method）所谓“属性”，就是对象的状态；所谓“方法”，就是对象的行为（完成某种任务）。比如，我们可以把动物抽象为 animal 对象，“属性”记录具体是那一种动物，“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 创建对象虽然 Object 构造函数和对象字面量都可以用来创建单个对象，但这些方式有明显的缺点：使用一个接口创建很多对象，会产生大量的重复代码。未解决这个问题，开发者们不停在探索。 工厂模式工厂模式是软件工程领域一种广为人知的设计模式。开发人员封装了一个函数，用函数来封装一个对象“模板”，这样可以少些一些代码。123456789function people(name,age)&#123; return &#123; 'name' : name, 'age' : age &#125;&#125;var people1 = people('Tom',23);var people2 = people('Peter',24);alert(people1.age); //23 这种模式虽然解决了创建多个相似对象的问题，这种方法的问题是，people1 和 people2 之间没有内在的联系，不能反映出它们是同一个原型对象的实例。然后，又出现了一种新的模式。 构造函数模式所谓“构造函数”，其实就是一个普通函数，但是内部使用了 this 变量。对构造函数使用 new 运算符，就能生成实例，并且 this 变量会绑定在实例对象上。1234567function People(name,age)&#123; this.name = name; this.age = age;&#125;var people1 = new People('Tom',23);var people2 = new People('Peter',24);alert(people2.name); //Peter 这时 people1 和 people2 会自动拥有一个 constructor 属性，指向他们的构造函数。12alert(people1.constructor == People); //truealert(people2.constructor == People); //true 或者也可以使用 instanceof 运算符，验证原型与实例之间的关系：12alert(people1 instanceof People); //truealert(people2 instanceof People); //true 构造函数应注意：1、函数名一般首字母大写，用来和普通函数区分；2、调用时必须使用 new 运算符，否则 this 将指向全局（属性和方法将属于 window）3、买有 return 语句。 构造函数模式虽然好用，但也不是没有缺点：造成内存浪费。我们给 People 添加一个方法：12345678910function People(name,age)&#123; this.name = name; this.age = age; this.run = function()&#123; alert('我会跑！'); &#125;&#125;var people1 = new People('Tom',23);var people2 = new People('Peter',24);people1.run(); 貌似没有什么为题。实际上，run 这个方法应该是每个实例共享的（因为每个人都会跑），但是我们每 new 一次，就会为新的实例重新定义 run 方法，造成内存浪费。1alert(people1.run == people2.run); //false 原型模式Javascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。1234567891011function People(name,age)&#123; this.name = name; this.age = age;&#125;People.prototype.run = function()&#123; alert('我会跑！');&#125;var people1 = new People('Tom',23);var people2 = new People('Peter',24);people1.run(); //我会跑！alert(people1.run == people2.run); //true 说明 people1 和 people2 的 run() 方法指向相同内存地址，是共享的。减少了内存的使用，提高了运行效率。 原型搜索机制：当访问一个实例属性时，首先会在实例中搜索该属性，如果找不到，则会继续搜索实例的原型。 继承 一句话，继承 就是让一个对象拥有另一个对象的属性或方法。（我是这么理解的） 原型链原型链 是 js 继承的主要方法。其主要思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。首先明确一下 构造函数、原型 和 实例 的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型的内部指针(对照下图理解这句话)。 假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是 原型链。原型链的基本模式：（一个构造函数的原型指向另一个构造函数的实例）123456789101112function Animal()&#123;&#125;Animal.prototype.type = function()&#123; return '动物';&#125;function People(name,age)&#123; this.name = name; this.age = age;&#125;People.prototype = new Animal(); //实现继承Animai()var people1 = new People();alert(people1.type()); //动物 最终的结果是：people1 指向 People 的原型，People 的原型又指向 Animal 的原型。 需要注意：注意一： 原型链的顶层为 Object 。这也是所有自定义类型都可以使用 toString()、valueOf() 的原因。注意二： 如果存在继承，那么子对象的实例属于所有所继承的对象。123alert(people1 instanceof People); //truealert(people1 instanceof Animal); //truealert(people1 instanceof Object); //true 注意三： 如果需要给子类型添加超类型中不存的方法，或者说要替换掉超类型中的方法，那么给原型添加方法的代码一定要放在替换原型的语句之后。123456789101112131415161718192021function Animal()&#123;&#125;Animal.prototype.type = function()&#123; return '动物';&#125;function People(name,age)&#123; this.name = name; this.age = age;&#125;People.prototype = new Animal(); //实现继承Animai()People.prototype.type = function()&#123; return '我也是动物';&#125;var people1 = new People();alert(people1.type()); //我也是动物 //超类型中的方法被覆盖People.prototype.type = function()&#123; return '我也是动物';&#125;People.prototype = new Animal();var people1 = new People();alert(people1.type()); //动物 注意四： 不能使用对象字面量创建原型方法，因为这样会重写原型链。 原型链的问题：问题一： 前面说过，包含引用类型值得原型属性会被所有实例共享。在通过原型实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成现在的原型属性了。12345678910111213function Color()&#123; this.color = ['red','blue','green'];&#125;function Flower()&#123;&#125;Flower.prototype = new Color(); //继承Colorvar flower1 = new Flower();flower1.color.push('black');alert(flower1.color); //red,blue,green,blackvar flower2 = new Flower();alert(flower2.color); //red,blue,green,black 问题二： 没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 借用构造函数这种技术是为了解决 原型链 中的问题而产生的，他的基本思想是：在子类型构造函数的内部调用超类型的构造函数。方式是使用 call() 或 apply() 方法，将父对象的构造函数绑定在子对象上。12345678910111213function Color()&#123; this.color = ['red','blue','green'];&#125;function Flower()&#123; Color.call(this); //继承Color&#125;var flower1 = new Flower();flower1.color.push('black');alert(flower1.color); //red,blue,green,blackvar flower2 = new Flower();alert(flower2.color); //red,blue,green 我们实际上在新创建的 Flower 实例的环境下调用了 Color 构造函数。这样一来，就会在新 Flower 对象上执行 Color 函数中定义的所有对象初始化代码。结果， Flower 的每个实例都会具有自己的 color 属性的副本。借用构造函数的问题：方法都在函数中定义，因此函数复用就无从谈起。所以很少单独使用。 组合继承将 原型链 和 构造函数 相结合，从而发挥两者之长的继承方式。思路是：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。12345678910111213141516171819202122232425262728function People(name)&#123; this.name = name; this.color = ['red','blue','green'];&#125;People.prototype.sayName = function()&#123; alert(this.name);&#125;function Book(name,age)&#123; People.call(this,name); //继承了People的name属性 this.age = age;&#125;Book.prototype = new People(); //继承方法Book.prototype.constructor = Book;Book.prototype.sayAge = function()&#123; alert(this.age);&#125;var book1 = new Book('js',23);book1.color.push('black');alert(book1.color); //red,blue,green,blackbook1.sayName(); //jsbook1.sayAge(); //23var book2 = new Book('java',44);alert(book2.color); //red,blue,greenbook2.sayName(); //javabook2.sayAge(); //44 People 构造函数定义了两个属性：name 和 color，然后给 People 的原型定义了 sayName() 方法。Book 构造函数在调用 People 构造函数是传入了 name 参数，紧接着又定义了自己的属性 age。然后，将 People 的实例赋值给 Book 的原型，然后又在该新原型上定义了 sayAge() 方法。这样一来，就可以让两个不同的 Book 实例即分别有自己的属性，又可以使用相同方法。]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面向对象</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 事件总结]]></title>
    <url>%2F2016%2F12%2F02%2Fevent%2F</url>
    <content type="text"><![CDATA[Javascript 和 HTML 之间的交互是通过 事件 来实现的。最早在 IE 中出现，被作为分担服务器端运算负载的一种手段。到现在，几乎所有的浏览器都支持事件处理。在 DOM2 级中得到规范。 事件流事件流 描述的是从页面中接受事件的顺序。IE 和 Netscape 提出了完全相反的事件流概念。事件冒泡： IE 中的事件流叫做 事件冒泡 ,即从最具体的元素逐级向外传播到较不具体的元素。（所有现代浏览器都支持事件冒泡）事件捕获： Netscape 提出了另一种事件流叫做 事件捕获 。他们的思想是最具体的元素应该最后接受到事件，所以事件捕获是 “从外向内” 传播的。DOM事件流： “DOM2级事件”规定了事件流包括三个阶段：首先发生事件捕获，然后是实际的目标接受到事件，最后一个阶段是事件冒泡。 汇总： IE8及更早的版本不支持 DOM2 级事件流。 事件处理程序事件就是用户或浏览器自身执行的某种动作。像click、load等都是事件的名字，而响应这个事件的函数就叫做 事件处理程序 。事件处理程序以 on 开头。Javascript 有三种事件模型：内联模型 、 脚本模型 和 DOM2级模型 。 内链模型： 被淘汰的方式，举个例子：1&lt;input type="button" value="Click me" onclick="alert('Clicked')" /&gt; 脚本模型： 这个是现在用的最多的一种方式：12345var btn = document.getElementById('button');btn.onclick = function()&#123; //指定事件 alert('Clicked');&#125;btn.onclick = null; //删除事件 DOM2级模型“DOM2级事件”定义了两个方法：（可用于所有 DOM 节点） addEventListener() &nbsp;&nbsp; 添加事件 removeEventListener() &nbsp;&nbsp; 移除事件 这两个方法都接受三个参数：要处理的事件名（click、mouseover）、事件处理程序（一个匿名函数） 和 一个布尔值（最后一个布尔值如果是 true 表示在捕获阶段执行事件，如果是 false 表示在冒泡阶段执行事件。） PS: 大多数情况下，都将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度兼容不同的浏览器。 1234var btn = document.getElementById('button');btn.addEventListener('click',function()&#123; alert('Clicked'); &#125;,false); DOM2方式的特点：1、可以为同一个元素添加多个事件处理程序，他们会按照顺序依次执行。2、移除事件貌似麻烦了很多。 123456789101112131415var btn = document.getElementById('button');btn.addEventListener('click',function()&#123; alert('Clicked'); &#125;,false);btn.removeEventListener('click',function()&#123; alert('Clicked'); //这样是不能移除事件的 &#125;,false); //因为这两个匿名函数已经不是同一个函数了//必须这样写var btn = document.getElementById('button');var handler = function()&#123; alert('Clicked');&#125;btn.addEventListener('click',handler,false);btn.removeEventListener('click',handler,false); //这样才行 IE中的事件处理程序IE 实现了与 DOM 中类似的两个方法： attachEvent() &nbsp;&nbsp; 添加事件 detachEvent() &nbsp;&nbsp; 移除事件 这两个方法接受两个参数：事件处理程序的名称（onclick、onmouseover） 和 事件处理函数（一个匿名函数）。（IE 默认使用冒泡方式） 需要注意的是它 DOM2 中两个方法的区别：区别一： 第一个参数是 onclick ，而不是 click 。区别二： 事件处理程序会在全局作用于下运行，里面的 this 指的是 window 。（在做跨浏览器是这一点要特别注意） 1234var btn = document.getElementById('button');btn.attachEvent('onclick',function()&#123; alert(this === window); //true &#125;); 优缺点：优点：同样可以添加多个事件处理程序。但是，这些事件是按添加的相反顺序执行。缺点：和上面一样，使用匿名函数是不能被移除。需要传入对相同函数的引用。 跨浏览器事件处理程序我们要创建一个方法，视情况分别使用 传统模型、DOM2级模型 或者 IE 事件处理程序。这个方法接受三个参数：要操作的元素、事件类型 和 事件处理函数。1234567891011121314151617181920//添加事件function addEvent(element,type,fn)&#123; if(element.addEventListener)&#123; element.addEventListener(type,fn,false); &#125;else if(element.attachEvent)&#123; element.attachEvent('on'+type,fn); &#125;else&#123; element['on'+type] = fn; &#125;&#125;//移除事件function removeEvent(element,type,fn)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,fn,false); &#125;else if(element.detachEvent)&#123; element.detachEvent('on'+type,fn); &#125;else&#123; element['on'+type] = null; &#125;&#125; 事件对象在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如鼠标操作导致的事件对象中，包含鼠标位置的信息，键盘操作导致的事件对象中，包含与按键有关的信息。所有浏览器都支持 event 对象，不过支持的方式不同。 W3C中的事件对象无论指定事件处理程序时使用什么方法（DOM0级、DOM2级等），都会传入 event 对象。1234btn = document.getElementById('button');addEvent(btn,'click',function(event)&#123; alert(event.type); //click &#125;); event 对象的属性和方法： (这里之列举最常用的) 属性/方法 说明 target 事件的目标 type 被触发的事件类型 currentTarget 其事件处理程序当前正在处理事件的那个元素 cancelable 表明是否可以取消当前事件的默认行为 preventDefault() 取消时间的默认行为。如果 cancelable 是 true 就可以使用这个方法 bubbles 表明事件是否冒泡 stopPropagation() 取消时间的进一步捕获或冒泡。如果 bubbles 为 true 则可以使用这个方法 注意：1、在事件执行内部， this 始终等于 currentTarget 。而 target 只包含事件的实际目标。也就是说 this 和 currentTarget 返回的是你为事件指定的目标元素，而 target 是真正触发这个事件的目标。2、只有 cancelable 的值为 true 的事件，才可以使用 preventDefault() 来取消器默认行为。1234var link = document.getElementById('myLink');link.onclick = function(event)&#123; event.preventDefault(); //点击链接不会跳转&#125; 3、stopPropagation() 方法用于立即停止事件冒泡或捕获。12345678var btn = document.getElementById('button');btn.onclick = function(event)&#123; alert('Clicked'); event.stopPropagation(); //如果不阻止事件的传播，点击 btn 后下面的事件也会执行&#125;document.body.onclick = function()&#123; alert('Body Element');&#125; IE中的事件对象与访问 W3C 中的 event 对象不同，IE 中的 event 对象的访问 取决于指定事件处理程序的方法。脚本模式： event 作为 window 对象的一个属性存在1234btn.onclick = function()&#123; var event = window.event; alert(event.type); //click&#125; DOM2级： event 作为一个参数被传入事件处理程序。123btn.attachEvent('onlick',function(event)&#123; alert(event.type); //click &#125;); IE 中的 event 对象的属性和方法： 属性/方法 说明 cancelBubble 默认值为 false，将其设置为 true 时可以取消事件冒泡（相当于 DOM 中的 stopPropagation() 方法） returnValue 默认值为 true，将其设置为 false 是可以取消时间的默认行为（相当于 DOM 中的 preventDefault() 方法） srcElement 事件的目标（和 DOM 中的 target 一样） type 被触发事件的类型 注意：1、因为事件处理程序的 作用域 是由指定的方式决定的，所以要特别注意123456btn.onclick = function()&#123; alert(window.event.srcElement === this); //true&#125; //这里的this指的是btnDOMbtn.attachEvent('onclick',function(event)&#123; alert(event.srcElement === this); //false &#125;); //因为这里的this指的是window 2、只要将 returnValue 属性的值设置为 false 就可以阻止事件的默认行为1234var link = document.getElementById('myLink');link.onclick = function()&#123; window.event.returnValue = fasle; //链接不会跳转&#125; 3、cancelBubble 属性用来停止事件的冒泡（IE不支持事件捕获）这里就不举例了。 跨浏览器的事件对象这里有4个方法：123456789101112131415161718192021222324//获取对象function getEvent(event)&#123; return event ? event : window.event;&#125;//获取事件目标元素targetfunction getTarget(event)&#123; return event.target || event.srcElement;&#125;//阻止默认行为function preventDefault(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else if(event.returnValue)&#123; event.returnValue = false; &#125;&#125;//阻止冒泡function stopPropagation(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else if(event.cancelable)&#123; event.cancelable = true; &#125;&#125; 常用事件类型汇总常用的事件类型和具体用法你都可以在这里找到：HTML DOM 事件对象自己介绍一下 鼠标事件 和 键盘事件 鼠标事件当浏览器执行鼠标事件的时候回以函数的形式返回一个 event 对象event对象有一个 button 属相，按下鼠标的不同按键会返回不同的值（貌似很有用）12345678910document.onclick = function(event)&#123; event = event || window.event; alert(event.button); //chrome 左键弹出0 其它不支持；FF 左键0 中键1 右键2； //IE 左键0 中键1 右键不支持&#125;//尝试一次别的事件document.onmouseup = function(event)&#123; event = event || window.event; alert(event.button); //chrome 、IE 和 Firefox都符合W3C标准，做到了兼容&#125; 键盘事件键盘事件一共有三种：keydown &nbsp;&nbsp; 键盘按下是执行keyup &nbsp;&nbsp; 键盘松开是执行keypress &nbsp;&nbsp; 只支持字符键（能打印出字符的键，不包括enter、shift、Ctrl等）这里理解一个概念键码： 键盘上每个键都会对应一个数字，这个数字就称为键码。（字符的键码就是其对应的ASICC编码（字母的话按小写来），非字符也会有一个对应的值）。怎么获得这个键码呢？？用到event对象的另一个属性 keyCode1234document.onkeydown = function(event)&#123; event = event || window.event; alert(event.keyCode); //这时按下键盘上的每个键都会返回对应的键码&#125; 如果使用keypress方法来返回keyCode呢？12345document.onkeypress = function(event)&#123; event = event || window.event; alert(event.keyCode); //Chrome和IE 非字符键不返回，字符键返回对应ASCII编码，并且区分大小写 //forefox 非字符键不返回，字符键全部返回 0&#125; 注意：键码在不同浏览器上可能会有所不同（比如 ; 分号，，可以自己试一下）。那么怎么做到兼容呢？？再来认识一个概念：字符编码： 这个是唯一的1234 document.onkeypress = function(event)&#123; event = event || window.event; alert(event.charCode); //返回对应的字符编码，（;分号可以兼容了）&#125; 如果只用到字符的事件就用 keypress 的 charCode方法 事件委托由于事件处理程序可以为现代 WEB 应用程序提供交互能力，因此许多开发人员会不分青红皂白地想页面中添加大量的处理程序。这样做会导致什么问题呢？首先，每个函数都是对象，都会占用内存；其次，必须事件指定好所有事件处理程序而导致 DOM 访问次数过多，延迟整个页面的交互就绪时间。对“事件处理程序过多”问题的解决方案就是 事件委托 。事件委托利用 事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。举个例子： 下面是三个不同的按钮。12345&lt;div id="box"&gt; &lt;button id="btn1"&gt;这是按钮A&lt;/button&gt; &lt;button id="btn2"&gt;这是按钮B&lt;/button&gt; &lt;button id="btn3"&gt;这是按钮C&lt;/button&gt;&lt;/div&gt; 我们要为他们指定 click 事件，传统意义上我们会分别为他们指定事件，就像下面这样做：123456789101112var btn1 = document.getElementById('btn1');var btn2 = document.getElementById('btn2');var btn3 = document.getElementById('btn3');btn1.click = function()&#123; alert('这是按钮A！');&#125;btn2.click = function()&#123; alert('这是按钮B！');&#125;btn3.click = function()&#123; alert('这是按钮C！');&#125; 在来看看用 事件委托 应该怎么做：123456789101112131415addEvent(document,'click',function(event)&#123; var event = getEvent(event); var target = getTarget(event); switch(target.id)&#123; case 'btn1': alert('这是按钮A！'); break; case 'btn2': alert('这是按钮B！'); break; case 'btn3': alert('这是按钮C！'); break; &#125;&#125;); 对比就会发现这种方式的优势，首先，我们只指定了一个事件就完成了为三个按钮添加事件的功能，较少了程序运行所需的内存；另外，只有一次 DOM 操作，这使得交互会很快就绪。是不是很完美。 适合采用 事件委托 的事件包括 click、mousedown、mouseup、keydown、keyup 和 keypress。(必须支持事件冒泡)]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>事件</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地 git 部署到 GitHub]]></title>
    <url>%2F2016%2F11%2F08%2Fgithub%2F</url>
    <content type="text"><![CDATA[GitHub的本意是旨在成为一种开放的软件协作平台，但它目前已成为一个巨大的综合性的平台，其作用远远超过单纯地开源代码。它已经被新一代的人们授权进行协作、创造和生产。GitHub不仅仅是一个工具：我们正在见证一个新文化的诞生。 将本地项目上传到 GitHub 有很多种方法，综合来看使用 git 命令行的方法最简单方便，所以这里只介绍这方法。。 建立git仓库cd到你的本地项目根目录下，执行git命令：1git init 将项目的所有文件添加到仓库中1git add . 如果只想添加某个特定的文件，只需要把 . 换成特定的文件名即可 将add的文件commit到仓库1git commit -m &quot;注释语句&quot; 到GitHub上创建自己的Repository,创建页面如下图所示： 仓库创建完成后，我们要拿到仓库的https地址，红框里的： 重点！！将本地的仓库关联到GitHub1git remote add origin https://github.com/...... 后面的是你上一步获取到的仓库url 上传GitHub之前，需要先pull一下1git pull origin master 最后一步，上传本地项目到GitHub远程仓库1git push -u origin master 执行完成后，如果没有异常，等待一会就可以了，中间可能会让你输入username和password，你只要输入自己的GitHub账号和密码就好了。。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
